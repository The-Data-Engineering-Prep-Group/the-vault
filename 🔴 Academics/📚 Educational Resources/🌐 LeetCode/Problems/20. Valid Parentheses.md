---
title: 20. Valid Parentheses
created: 2023-09-03 23:01
updated: 2023-09-04 12:36
authors:
  - Edmund Leibert III
tags:
  - üî¥-academics/üìö-educational-resources/name/leetcode
  - üî¥-academics/üìö-educational-resources/source-format/internet/website
  - üî¥-academics/üìö-educational-resources/name/üåê-leetcode/üîñ-bookmark/üåê-leetcode/üåê-leetCode-‚ñπ-üìã-table-of-contents/problems/20-valid-parentheses
  - üî¥-academics/üìö-educational-resources/name/üåê-leetcode/üè∑Ô∏è-tag/problem/tag/topic/string
  - üî¥-academics/üìö-educational-resources/name/üåê-leetcode/üè∑Ô∏è-tag/problem/tag/topic/stack
  - study-note
cards-deck: üî¥ Academics::üìö Educational Resources::üåê LeetCode::Problems::20. Valid Parentheses
---

#  üåê LeetCode

---

## üï∏Ô∏è All Mention(s): 

---

## üîô Previous Note(s):

---

##  Problems

### 20. Valid Parentheses

> [!info]+ Where can the problem be found?
> The problem can be found here: [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/description/)

#### Solution (C++)

Ôπá<br>
What is the _optimal_ solution to this problem? If there are multiple, list them out and compare.

#card 

**Approach #1**: Stacks üåü

```cpp
#include <stack>
#include <unordered_map>

using namespace std;

class Solution {
public:
    bool isValid(string s) {
        stack<char> brackets;
        unordered_map<char, char> mapping = {{')', '('}, {'}', '{'}, {']', '['}};

        for (auto c : s) {
            if (mapping.count(c)) {
                // Check for matching bracket at the top of stack
                char topElement = brackets.empty() ? '#' : brackets.top();
                brackets.pop();

                if (mapping[c] != topElement) {
                    return false;
                }
            } else {
                // An opening bracket, push onto stack
                brackets.push(c);
            }
        }

        // Stack should be empty for balanced brackets
        return brackets.empty();
    }
};
```

- **Asymptotic Complexity**:
	- Time: $\mathcal{O}(n)$
	- Space: $\mathcal{O}(n)$

‚åÇ
<br>Ôπà<br>^1693807973643


##### Attempt #1 :: üìÜ 2023-09-03 23:01 :: ‚ùå

###### Performance

- ‚è≤**Time**: `0:13:01`
- üßîüèΩ‚Äç‚ôÇÔ∏è **Author(s)**: 
	- `Edmund Leibert III`

###### Notes

Ôπá<br>
Is the following code valid?

```cpp
#include <stack>
#include <unordered_map>

using namespace std;

class Solution {
public:
    bool isValid(string s) { 
        stack<char> brackets;

        for(auto c : s) {
            if(!brackets.empty()) {
                if( c == ')' && brackets.top() == '(') {
                    brackets.pop();
                    continue;
                }
                if( c == '}' && brackets.top() == '{') {
                    brackets.pop();
                    continue;
                }
                if( c == ']' && brackets.top() == '[') {
                    brackets.pop();
                    continue;
                }
            }
            else {
                brackets.push(c);
            }
        }

        if(!brackets.empty()) {
            return false;
        }
        else {
            return true;
        }
    }
};
```

#card 

While the following code _will_ compile, it is **not** logically correct.
- Even if the stack is empty _and_ we can‚Äôt pop the top element of the stack, we still **should** push the current character (i.e., `c`) to the stack. 
- Currently, the logic of the code does not do that.

Here is a corrected version‚Ä¶

```cpp
#include <stack>
#include <unordered_map>

using namespace std;

class Solution {
public:
    bool isValid(string s) { 
        stack<char> brackets;

        for(auto c : s) {
            if(!brackets.empty()) {
                if( c == ')' && brackets.top() == '(') {
                    brackets.pop();
                    continue;
                }
                if( c == '}' && brackets.top() == '{') {
                    brackets.pop();
                    continue;
                }
                if( c == ']' && brackets.top() == '[') {
                    brackets.pop();
                    continue;
                }
                brackets.push(c);
            }
            else {
                brackets.push(c);
            }
        }

        if(!brackets.empty()) {
            return false;
        }
        else {
            return true;
        }
    }
};
```

‚åÇ
<br>Ôπà<br>^1693807973653

Ôπá<br>
Can the following code be improved? If so, how?

```cpp
#include <stack>
#include <unordered_map>

using namespace std;

class Solution {
public:
    bool isValid(string s) { 
        stack<char> brackets;

        for(auto c : s) {
            if(!brackets.empty()) {
                if( c == ')' && brackets.top() == '(') {
                    brackets.pop();
                    continue;
                }
                if( c == '}' && brackets.top() == '{') {
                    brackets.pop();
                    continue;
                }
                if( c == ']' && brackets.top() == '[') {
                    brackets.pop();
                    continue;
                }
                brackets.push(c);
            }
            else {
                brackets.push(c);
            }
        }

        if(!brackets.empty()) {
            return false;
        }
        else {
            return true;
        }
    }
};
```

#card 

Yes, it can.

1. Use an `unordered_map` to map closing brackets to their respective opening brackets for easy lookup.
2. Check for the validity of each character before pushing it onto the stack.
3. Use the stack's size to quickly determine whether the brackets are balanced at the end of the string.

```cpp
#include <stack>
#include <unordered_map>

using namespace std;

class Solution {
public:
    bool isValid(string s) {
        stack<char> brackets;
        unordered_map<char, char> mapping = {{')', '('}, {'}', '{'}, {']', '['}};

        for (auto c : s) {
            if (mapping.count(c)) {
                // Check for matching bracket at the top of stack
                char topElement = brackets.empty() ? '#' : brackets.top();
                brackets.pop();

                if (mapping[c] != topElement) {
                    return false;
                }
            } else {
                // An opening bracket, push onto stack
                brackets.push(c);
            }
        }

        // Stack should be empty for balanced brackets
        return brackets.empty();
    }
};
```

>[!important]+ This is solution is *faster*!
> Not that in this solution we *immediately* return `false` if a corresponding closing bracket is **not** at the top of a stack for when `c` is an opening bracket.

‚åÇ
<br>Ôπà<br>^1693808675328


---

## üîú Next Note(s):

---
