---
title: 219. Contains Duplicate II
created: 2023-09-10 17:06
updated: 2023-09-11 00:05
authors:
  - Edmund Leibert III
tags:
  - 🔴-academics/📚-educational-resources/name/🌐-leetcode
  - 🔴-academics/📚-educational-resources/source-format/internet/website
  - 🔴-academics/📚-educational-resources/discipline/computer-science
  - 🔴-academics/📚-educational-resources/name/🌐-leetcode/🔖-bookmark/🌐-leetcode/problems/219-contains-duplicate-ii
  - 🔴-academics/📚-educational-resources/name/🌐-leetcode/🏷️-tag/problem/difficulty/easy
  - 🔴-academics/📚-educational-resources/name/🌐-leetcode/🏷️-tag/problem/tag/topic/array
  - 🔴-academics/📚-educational-resources/name/🌐-leetcode/🏷️-tag/problem/tag/topic/hash-table
  - 🔴-academics/📚-educational-resources/name/🌐-leetcode/🏷️-tag/problem/tag/topic/sliding-window
  - study-note
cards-deck: 🔴 Academics::📚 Educational Resources::🌐 LeetCode::Problems::219. Contains Duplicate II
---

# 🌐 Structy

---

## 🕸️ All Mention(s): 

---

## 🔙 Previous Note(s):

---

## 0. Introduction

### 219. Contains Duplicate II

> [!info]+ Where can the problem be found?
> The problem can be found here: [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/)

#### Solution (C++)

﹇<br>
What is the _optimal_ solution to this problem? Provide analysis regarding what differentiates it to other approaches/solutions.

#card 

**Approach #3: Hash Table** ⭐

```cpp
#include <unordered_map>
#include <cmath>

using namespace std;

class Solution {
public:
	bool containsNearbyDuplicate(vector<int>& nums, int k) {
		unordered_map<int, int> numMap; // val, pos
		if(nums.empty() || nums.size() == 1) {
			return false;
		}
		for(int i {0}; i < nums.size(); i++) {
			if (numMap.find(nums[i]) == numMap.end()) {
				numMap[nums[i]] = i;
				if(numMap.size() > k) {
					numMap.erase(nums[i - k]);
				}
			}
			else {
				if( abs(i - numMap[nums[i]]) <= k ) {
					return true;
				}
			}
		}
		return false;
	}
};
```
	
- **Intuition**
	- Keep a sliding window of $k$ elements using Hash Table.
- **Algorithm**
	- From the previous approaches, we know that even logarithmic performance in `search` is not enough. In this case, we need a data structure supporting constant time `search`, `delete` and `insert` operations. Hash Table is the answer. The algorithm and implementation are almost identical to [Approach #2](https://leetcode.com/problems/contains-duplicate-ii/editorial/#approach-2-binary-search-tree-time-limit-exceeded).
	- Loop through the array, for each element do
		- Search current element in the HashTable, return `true` if found
		- Put current element in the HashTable
		- If the size of the HashTable is larger than $k$, remove the oldest item.
	- Return `false`
- **Complexity Analysis**
	- **Time Complexity**: $\mathcal{O}(n)$.  
		- We do $n$ operations of `search`, `delete` and `insert`, each with constant time complexity.
	- **Space Complexity**: $\mathcal{O}(min(n,k))$.  
		- The extra space required depends on the number of items stored in the hash table, which is the size of the sliding window, $\mathcal{O}(min(n,k))$.

⌂
<br>﹈<br>^1694399078847



##### Attempt #1 :: 2023-09-10 17:09 -07:00 :: ❌ :: \[Author: Edmund Leibert III\]

###### Performance

- ⏲️ **Time**: `0:20:00`
- 🧔🏽‍♂️ **Author(s)**:
	- Edmund Leibert III

###### Notes

﹇<br>
In C++, does `unordered_map` support the method `.remove()`?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

No, you should instead use the `erase()` function. Remember, to remove a key and its associated value from an `unordered_map` in C++, you can use the `erase` function. Here is an example:

```cpp
#include <unordered_map>

int main() {
    std::unordered_map<int, int> myMap;

    // Insert a key-value pair into the map
    myMap[1] = 100;

    // Remove the key-value pair with key 1
    myMap.erase(1);

    return 0;
}
```

In this code, `myMap.erase(1);` removes the key-value pair from the map where the key is `1`. If the key does not exist in the map, this operation has no effect.

⌂
<br>﹈<br>^1694399078857




﹇<br>
In C++, how can you remove a _key_ and its associated _value_ in an `std::unordered_map` in C++ using just the _key_?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

```cpp
#include <unordered_map>

int main() {
    std::unordered_map<int, int> myMap;

    // Insert a key-value pair into the map
    myMap[1] = 100;

    // Remove the key-value pair with key 1
    myMap.erase(1);

    return 0;
}
```


⌂
<br>﹈<br>^1694399078862




﹇<br>
Is the following code valid?

```cpp
#include <unordered_map>

int main() {
    std::unordered_map<int, int> myMap;

    // Insert a key-value pair into the map
    myMap[1] = 100;

    // Remove the key-value pair with key 1
    myMap.remove(1);

    return 0;
}
```

#card 

No, the above code will _not_ compile.
- This is because `std::unordered_map` does not have a `remove()`  function. One should instead use `erase()`.

⌂
<br>﹈<br>^1694399078867



﹇<br>
When using a **map** when iterating across a container to find values in a window that satisfy a certain condition, how can you ensure that the “window” slides? 

#card 

When using this approach our “sliding window” is represented in our **map**, as such, we need to decrement the earliest incremented key-value pair that was inserted into the map.

⌂
<br>﹈<br>^1694399078872


---

## 🔜 Next Note(s):

---

