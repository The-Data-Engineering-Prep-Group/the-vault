---
title: 003. max-value 👨🏽‍💻
created: 2023-08-04 01:58
updated: 2023-10-08 22:03
authors:
  - Edmund Leibert III
tags:
  - 🔴-academics/📚-educational-resources/name/🌐-structy
  - 🔴-academics/📚-educational-resources/source-format/internet/website
  - 🔴-academics/📚-educational-resources/discipline/computer-science
  - 🔴-academics/📚-educational-resources/name/🌐-structy/🔖-bookmark/0-introduction/003-max-value-🧑🏽‍💻
  - 🔴-academics/📚-educational-resources/name/🌐-structy/🏷️-tag/challenge
  - study-note
cards-deck: 🔴 Academics::📚 Educational Resources::🌐 Structy::0. Introduction::003. max-value 🧑🏽‍💻
---

# 🌐 Structy

---

## 🕸️ All Mention(s): 

---

## 🔙 Previous Note(s):

---

## 0. Introduction

### 003. max-value 👨🏽‍💻

#### 🧭 Approach

﹇<br>
When iterating across a container to find some extreme value (e.g. maximum _or_ minimum), what initial value should we set for our `max_elem` (or `min_elem`)?

#card 

Should always (if the language, library, etc. allows) use $-\infty$ or $\infty$.

⌂
<br>﹈<br>^1694730801689




#### 📽️ Walkthrough

##### C++

﹇<br>
Does C++ support $-\infty$?

#card 

Yes! You can include the `<limits>` library and then call `numeric_limits<T>::infinity()`. Note that the `infinity()` member function of `std::numeric_limits` does _not_ support infinity for some types like `int`, `long long`, etc. 

Can use the member constant `has_infinity` to see if a type supports `infinity()` like so…

```cpp
#include <iostream>
#include <limits>
 
int main()
{
    std::cout << std::boolalpha
              << std::numeric_limits<int>::has_infinity << '\n'
              << std::numeric_limits<long>::has_infinity << '\n'
              << std::numeric_limits<float>::has_infinity << '\n'
              << std::numeric_limits<double>::has_infinity << '\n';
}
```

Possible output:

```
false
false
true
true
```

⌂
<br>﹈<br>^1694730801695


##### Python

##### JavaScript

##### Java

#### 💡Solution

> [!Note]+ Why is this section empty?
> For notes regarding solution(s), attempt(s), etc., refer to section below that is a _universal_ template for notes of such concern.


#### Solution (C++)

﹇<br>
What is the _optimal_ solution to this problem? If there are multiple, list them out and compare.

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- **Approach #1**: Using the `max_element()` function
	1. Just use the `std::max_element()`!
	- **Computational Complexity**:
		- Time: $\mathcal{O}(n)$
		- Space: $\mathcal{O}(1)$

- **Approach #2**: Using pointers ⭐
	1. Create a variable called `maxValue` that will be initially set to the `numeric_limits<float>::max()`.
	2. Iterate across the container.
		1. If the current `maxValue` is less than the current value, set `maxValue` to that value.
	- **Asymptotic Analysis**:
		- Time: $\mathcal{O}(n)$
		- Space: $\mathcal{O}(1)$

- **Approach #3**:  Using the `max`
	1. Create a variable called `maxValue` that will be initially set to the `numeric_limits<float>::max()`.
	2. Iterate across the container.
		1. If the current `maxValue` is less than the current value, set `maxValue` to that value.
	- **Asymptotic Analysis**:
		- Time: $\mathcal{O}(n)$
		- Space: $\mathcal{O}(1)$

- **Official Structy Solution**:

	Code:
	
	```cpp
	#include <vector>
	#include <limits>
	
	float maxValue(std::vector<float> numbers) {
	  float max = -std::numeric_limits<float>::infinity();
	  for (float num : numbers) {
		if (num > max) {
		max = num;
		}
	  }
	  return max;
	}
	```

	- n = # numbers
	- Time: O(n)
	- Space: O(1)

⌂
<br>﹈<br>^1694722882728


##### Attempt #3 :: 📆 2023-09-14 12:09 -07:00 :: ✅ :: \[Author(s): Edmund Leibert III\]

###### Performance

- ⏲️ **Time**: `0:01:00`
- 🧔🏽‍♂️ **Author(s)**:
	- Edmund Leibert III

###### Notes

﹇<br>
Is the following code valid?

```cpp
float maxValue(std::vector<float> numbers) {
    // todo
    int max_elem = numeric_limits<float>::lowest();

    for(auto elem : numbers) {
        max_elem = elem > max_elem ? elem : max_elem;
    }

    return max_elem;
}
```

#card 

This code is logically incorrect. The issue is related to the precision of floating point numbers. In your code, you’re using an `int` variable `max_elem` to store the maximum value, which should be a `float`. This can cause precision issues when comparing and assigning floating point numbers. Here’s the corrected code:

```cpp
#include <vector>
#include <limits>

using namespace std;

float maxValue(vector<float> numbers) {
    float max_elem = numeric_limits<float>::lowest();

    for(auto elem : numbers) {
        max_elem = max(elem, max_elem);
    }

    return max_elem;
}
```

In this corrected code, `max_elem` is a `float`, which matches the type of the elements in your vector. The `max()` function from the `<algorithm>` header is used to find the maximum value, which can help avoid precision issues.

⌂
<br>﹈<br>^1694730801700


﹇<br>
What _type_ does `max()` return? What _type_ does `max_element()` return?

#card 

- `ranges::max()`: This function compares two values and returns the maximum value. It does not return an iterator.
- `ranges::max_element()`: This function returns an iterator pointing to the maximum element in a range. If there are multiple maximum elements, it returns the first one. So, you need to dereference the iterator to get the actual value.

Here’s an example:

```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};

    // Using ranges::max()
    int a = 5;
    int b = 10;
    std::cout << "Max: " << std::ranges::max(a, b) << '\n';  // prints: Max: 10

    // Using ranges::max_element()
    auto it = std::ranges::max_element(v);
    std::cout << "Max Element: " << *it << '\n';  // prints: Max Element: 5

    return 0;
}
```

In this example, `ranges::max(a, b)` returns the maximum of `a` and `b`, which is `10`. `ranges::max_element(v)` returns an iterator pointing to the maximum element in the vector `v`, which is `5`. We dereference the iterator (`*it`) to get the actual value.

⌂
<br>﹈<br>^1694723693128



﹇<br>
Why can you do `ranges::max(1,2)`, but for more than comparing two elements we need to use an initializer list? Can you just do `ranges::max(1,2,3,4)` without using the initializer list?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

[The `ranges::max()` function in C++20 is designed to compare two values and return the maximum](https://en.cppreference.com/w/cpp/algorithm/ranges/max)[1](https://en.cppreference.com/w/cpp/algorithm/ranges/max). If you want to find the maximum of more than two values, you need to use an initializer list, as in…
```cpp
ranges::max({1, 2, 3, 4})
```
<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max)</sup>.

This is because C++ functions can’t natively take a variable number of arguments of any type. [There are ways to achieve this using templates and variadic arguments, but these are more complex and not used in the standard library functions](https://stackoverflow.com/questions/1657883/variable-number-of-arguments-in-c)<sup>[\[2\]](https://stackoverflow.com/questions/1657883/variable-number-of-arguments-in-c)</sup>.

So, while it might seem more intuitive to write `ranges::max(1, 2, 3, 4)`, this isn’t supported in C++. [You need to use an initializer list or another container that holds all the values you want to compare](about:blank#)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max)</sup>.

⌂
<br>﹈<br>^1694722903499


﹇<br>
Can `ranges::max()` take multiple arguments?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

Yes, the `ranges::max()` function in C++20 can take multiple arguments. [It compares all the arguments and returns the maximum value](https://en.cppreference.com/w/cpp/algorithm/ranges/max)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max)</sup>. Here’s an example:

```cpp
#include <iostream>
#include <ranges>

int main() {
    std::cout << "Max: " << std::ranges::max({1, 2, 3, 4, 5}) << '\n';  // prints: Max: 5
    return 0;
}
```

In this example…

```cpp
ranges::max({1, 2, 3, 4, 5})
``` 

returns the maximum value in the initializer list `{1, 2, 3, 4, 5}`, which is `5`<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max)</sup>.

Remember that this function is part of C++20, so you’ll need a compiler that supports C++20 to use it.

⌂
<br>﹈<br>^1694722831579



﹇<br>
What is the difference between `ranges::max()` and` ranges::max_element()`?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

[The `ranges::max()` and `ranges::max_element()` functions in C++20 are used to find the maximum value in a range, but they do so in slightly different ways](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)</sup>:

- `ranges::max(a, b)`: This function compares two values and returns the maximum. [If more than two values are given, it returns the maximum value among all the arguments](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)</sup>.
	- Here’s an example of using `ranges::max()`:
		```cpp
		#include <iostream>
		#include <ranges>
		
		int main() {
		    int a = 5;
		    int b = 10;
		    std::cout << "Max: " << std::ranges::max(a, b) << '\n';  // prints: Max: 10
		    return 0;
		}
		```
	- In this example, `ranges::max(a, b)` returns the maximum of `a` and `b`, which is `10`.

- `ranges::max_element(first, last)`: This function returns an iterator pointing to the maximum element in the range `[first, last)`. [If there are multiple maximum elements, it returns the first one](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)</sup>.
	- And here’s an example of using `ranges::max_element()`:
		```cpp
		#include <iostream>
		#include <vector>
		#include <ranges>
		
		int main() {
			std::vector<int> v = {1, 2, 3, 4, 5};
			auto it = std::ranges::max_element(v);
			std::cout << "Max Element: " << *it << '\n';  // prints: Max Element: 5
			return 0;
		}
		```
	- In this example, `ranges::max_element(v)` returns an iterator pointing to the maximum element in the vector `v`, which is `5`. We dereference the iterator (`*it`) to get the actual value.

So, if you want to find the maximum value among a few specific values, you can use `ranges::max()`. If you want to find the maximum element in a range of elements (like an array or a vector), you can use `ranges::max_element()`. [Remember that `ranges::max_element()` returns an iterator, so you need to dereference it to get the actual value](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)</sup>.

Remember that this function is part of C++20, so you’ll need a compiler that supports C++20 to use it.

⌂
<br>﹈<br>^1694722831583


﹇<br>
If I wish to use `ranges` in C++, what must I _always_ make sure to include first?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

First, to use the `ranges` library in C++, you must be using C++20 or later. The `ranges` library is a part of the Standard Library that was added in C++20. It provides facilities for dealing with ranges of values. A range is an object that refers to a sequence of elements, such as an array, a list, or an I/O stream.

To use the `ranges` library, you need to include the `<ranges>` header in your code:

```cpp
#include <ranges>
```

Please make sure your compiler supports C++20 to use this feature. If it doesn’t, you might need to update your compiler or use a different one that does support C++20.

⌂
<br>﹈<br>^1694722831587


##### Attempt #2 :: 📆 2023-09-13 17:09 -07:00 :: ✅ :: \[Author(s): Edmund Leibert III\]

###### Performance

- ⏲️ **Time**: `0:04:15`
- 🧔🏽‍♂️ **Author(s)**:
	- Edmund Leibert III

###### Notes


As detailed in [cppreference](https://en.cppreference.com/), {1:`std::numeric_limits<T>::lowest`} returns the {2:lowest finite value representable by the numeric type `T`}, that is, a {2:finite value `x` such that there is no other finite value `y` where `y < x`}. This is different from `std::numeric_limits<T>::min()` for floating-point types. Only meaningful for bounded types.
^1694722831591

﹇<br>
What library is the `std::numeric_limits<T>` a part of?

*Note that T stands for template

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

Is defined in the `<limits>` header.

⌂
<br>﹈<br>^1694722831595


﹇<br>
What is the return value of `std::numeric_limits<bool>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

`false`

⌂
<br>﹈<br>^1694722831599



﹇<br>
What is the return value of `std::numeric_limits<char>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 
​
`0​`

⌂
<br>﹈<br>^1694722831602



﹇<br>
What is the return value of `std::numeric_limits<signed char>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0`​

⌂
<br>﹈<br>^1694722831606



﹇<br>
What is the return value of `std::numeric_limits<unsigned char>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0​`

⌂
<br>﹈<br>^1694722831610



﹇<br>
What is the return value of `std::numeric_limits<wchar_t>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0​`

⌂
<br>﹈<br>^1694722831614



﹇<br>
What is the return value of `std::numeric_limits<short>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0​`

⌂
<br>﹈<br>^1694722831618



﹇<br>
What is the return value of `std::numeric_limits<unsigned short>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0​`

⌂
<br>﹈<br>^1694722831623



﹇<br>
What is the return value of `std::numeric_limits<int>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0​`

⌂
<br>﹈<br>^1694722831627



﹇<br>
What is the return value of `std::numeric_limits<unsigned int>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0`​

⌂
<br>﹈<br>^1694722831632



﹇<br>
What is the return value of `std::numeric_limits<long>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0​`

⌂
<br>﹈<br>^1694722831636



﹇<br>
What is the return value of `std::numeric_limits<unsigned long>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0​`

⌂
<br>﹈<br>^1694722831639



﹇<br>
What is the return value of `std::numeric_limits<long long>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0`​

⌂
<br>﹈<br>^1694722831643



﹇<br>
What is the return value of `std::numeric_limits<unsigned long long>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

​`0​`

⌂
<br>﹈<br>^1694722831648



﹇<br>
What is the return value of `std::numeric_limits<float>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

`HUGE_VALF`

⌂
<br>﹈<br>^1694722831652



﹇<br>
What is the return value of `std::numeric_limits<double>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

`HUGE_VAL`

⌂
<br>﹈<br>^1694722831656



﹇<br>
What is the return value of `std::numeric_limits<long double>::infinity()` in C++?

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

`HUGE_VALL`

⌂
<br>﹈<br>^1694722831661




##### Attempt #1 :: 📆 2023-22-07 10:00 -07:00 :: ✅ :: \[Author(s): Edmund Leibert III\]

###### Performance

- ⏲️ **Time**: `0:05:00`
- 🧔🏽‍♂️ **Author(s)**:
	-  Edmund Leibert III

###### Notes

﹇<br>
In C++, how can you represent negative or positive infinity?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- One can use the <span class="spoiler">`limits`</span> library, which is part of the C++ Standard library.
- With that, you can use the function `numeric_limits<int>::infinity()` to call postive infinity of the type `int`. 
- If you wanted to negative infinity, you can simply do `-numeric_limits<int>::infinity()` to call negative infinity of the type `int`. 

⌂
<br>﹈<br>^1694722831665




﹇<br>
What is the downside of using `numeric_limits<int>::infinity()` than just using `numeric_limits<int>::double()`?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- `std::numeric_limits<int>::infinity()` return the representation of positive, **if available**. 
- However, `std::numeric_limits<int>::has_inifinity` returns `false` for `int`, meaning that `std::numeric_limits<int>::infinity()` does not return any meaningful value to compare with.

⌂
<br>﹈<br>^1694722831669




﹇<br>
How can I check the if a data type supports infinity?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

Use the `std::numeric_limits<int>::has_inifinity` to check if the value returned from that expression is `true` or `false`.

⌂
<br>﹈<br>^1694722831673




﹇<br>
When trying to assign the value *negative* infinity (of type `int`) via the `<limits>` library, where should one place the negative sign?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

`-numeric_limits<int>::infinity()` Note that the negative sign is placed *before* the whole expression.

⌂
<br>﹈<br>^1694722831678




﹇<br>
What does the `::` mean in the expression `numeric_limits<int>::infinity()`?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- In C++ programming language, the `::` is called the **scope resolution operator**. 
- It is used to specify the scope of a function or variable. 
	- In this case, `numeric_limits<int>::infinity()` means that the `infinity()` function is being called from the `numeric_limits` class template specialized for the `int` type. 

⌂
<br>﹈<br>^1694722831682




﹇<br>
What does `numeric_limits<int>::lowest()` return when the data type is of `int`?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- Returns the lowest  possible (negative) value of `int`
- Same as `numeric_limits<int>::min()`

⌂
<br>﹈<br>^1694722831687




﹇<br>
What does `numeric_limits<int>::min()` return when the data type is of `int`?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- Returns the lowest  possible (negative) value of `int`
- Same as `numeric_limits<int>::lowest()`

⌂
<br>﹈<br>^1694722831692




﹇<br>
What does `numerc_limits<int>::min()` return when the data type is of a floating-point type (i.e., `double`, `float`)?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- Return the minimum positive normalized value.
- Note, how this is different from when the data type is `int`.

⌂
<br>﹈<br>^1694722831697




﹇<br>
What does `numerc_limits<int>::min()` return when the data type is of a floating-point type? 

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- Return the lowest value (which can be negative) of the type.

⌂
<br>﹈<br>^1694722831702




﹇<br>
What can `double` and `float` be classified as? 

#card #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

 They can be classified as **floating point** data points.

⌂
<br>﹈<br>^1694722831706




﹇<br>
In C++, what is the difference between iterator based loops vs range-`for` loop? 

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- First and foremost, use range-`for` loops.
- A range-`for` loop uses iterators internally. The loop variable is the *dereferenced value*, not the iterator itself.

⌂
<br>﹈<br>^1694722831710




﹇<br>
In C++, does a range-`for` loop expose access to its internal iterators?  

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

A range-`for` loop does *not* expose access to its internal iterators.

⌂
<br>﹈<br>^1694722831714




﹇<br>
What are **containers** in C++?  

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- In C++, containers are data structures that store and organize a collection of objects in memory.
- They are parts of the C++ Standard Library and provide a convenient way to manage collections of data, offering different trade-offs in terms of…
	- performance
	- memory usage
	- functionality

⌂
<br>﹈<br>^1694722831717





﹇<br>
What are the main categories of containers in C++? 

#card-reverse  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

The main categories of <span class="spoiler">containers</span>…
- Sequence containers
- Associative containers
- Unordered associative containers
- Container adapters

⌂
<br>﹈<br>^1694722831721




﹇<br>
What type of container is `queue`?  

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

container adaptor

⌂
<br>﹈<br>^1694722831725




﹇<br>
What type of container is `stack`?  

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

container adaptor

⌂
<br>﹈<br>^1694722831728




﹇<br>
What are sequence containers?  

#card-reverse  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

- Store elements in a linear sequence, where each element has a specific position.
- Examples include…
	- <span class="spoiler">`std::vector`</span>: <span class="spoiler">A dynamic array that automatically resizes itself whenits capacity is exceeded. It provides fast random access and efficient insertions/deletion at the end, but inertions/deletions in the middle can be slow.</span> 
	- <span class="spoiler">`std::list`</span>: <span class="spoiler">A doubly-linked list that allows for fast insertinos and deletions at any position, but does not support random access.</span>
	- <span class="spoiler">`std::deque`:</span> <span class="spoiler">A double-ended queue that supports fast random access and efficient insertions/deletions at both the beginning and the end.</span>
	- <span class="spoiler">`std::forward_list` (sinceC++11)</span>: <span class="spoiler">A singly-linked list that allows for fast insertions and deletions at any position, but does not support random access or bidirectional traversal.</span>
	- <span class="spoiler">`std::array` (sineC++11)</span>: <span class="spoiler">A fixed-size array with a compile-time size, providing fast random access and a small memory footprint.</span>

⌂
<br>﹈<br>^1694722831732





﹇<br>
What are associative and unordered associative containers?

#card-reverse  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

- These containers store elements in a sorted or hashed manner, which allows for faster access, insertion, and deletion based on specific keys.
- Examples include…
	- <span class="spoiler">`std::set`</span>: <span class="spoiler">A sorted collection of unique elements, typically implemented as a balanced binary search tree.</span>
	- <span class="spoiler">`std::multiset`</span>: <span class="spoiler">Similar to `std::set`, but allows multiple instances of the same element.</span>
	- <span class="spoiler">`std::map`</span>: <span class="spoiler">A sorted collection of key-value pairs, with unique keys, typically implemented as a balanced binary search tree.</span>
	- <span class="spoiler">`std::multimap`</span>: <span class="spoiler">Similar to `std::map`, but allows multiple key-value pairs with the same key.</span>
	- <span class="spoiler">`std::unordered_set` (sinceC++11)</span>: <span class="spoiler">A hashed collection of unique elements, providing average constant-time access, insertion, and deletion.</span>
	- <span class="spoiler">`std::unordered_multiset` (sinceC++11)</span>: <span class="spoiler">Similar to `std::unordered_set`, but allows multiple instances of the same element.</span>
	- <span class="spoiler">`std::unordered_map` (sinceC++11)</span>: <span class="spoiler">A hashed collection of key-value pairs, with unique keys, providing average constant-time access, insertion, and deletion.</span>
	- <span class="spoiler">`std::unordered_multimap` (sinceC++11)</span>: <span class="spoiler">Similar to `std::unordered_map`, but allows multiple key-value pairs with the same key.</span>

⌂
<br>﹈<br>^1694722831736





﹇<br>
What are some key benefits of containers in C++?

#card-reverse  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp 

- These containers provide various iterator types that allow you to traverse and manipulate the elements in a uniform manner.
- Additionally, they are designed to worth withC++ standard library algorithms, which makes it easy to perform common operations such as…
	- <span class="spoiler">searching elements</span>
	- <span class="spoiler">sorting elements</span>
	- <span class="spoiler">transforming elements</span>

⌂
<br>﹈<br>^1694722831744





﹇<br>
In C++, what is an input iterator?

#card-reverse  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp
- A type of iterator that allows you to traverse a container in a read-only, forward direction.
	- It is the most basic iterator category in theC++ Standard Library
	- Provides the minimum functionality required for single-pass algorithms, like reading elements from an input stream, or iterating through elements of a container in a linear fashion.

⌂
<br>﹈<br>^1694722831754





﹇<br>
What requirements must an iterator satisfy?

#card-reverse #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

 *Don’t worry about this too much*
1. <span class="spoiler">Copy-constructible:</span>
2. <span class="spoiler">Copy-assignable:</span>
3. <span class="spoiler">Destructible:</span>
4. <span class="spoiler">Equality-comparable:</span>
5. <span class="spoiler">Incrementable/Decrementable:</span>

⌂
<br>﹈<br>^1694722831761





﹇<br>
What operations does an input iterator satisfy?

#card-reverse  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

1. <span class="spoiler">Dereference (`*`):</span> <span class="spoiler">Access the value pointed to by the iterator (read-only</span>
2. <span class="spoiler">Increment (`++`):</span> <span class="spoiler">Move the iterator to the next element in the container.</span>
3. <span class="spoiler">Equality comparison (`==`):</span> <span class="spoiler">Check if two iterators are equal (point to the same element).</span>
4. <span class="spoiler">Inequality comparison (`!=`):</span> <span class="spoiler">Check if two iterators are not equal (point to different elements).</span>

⌂
<br>﹈<br>^1694722831767




﹇<br>
First and foremost, what exactly is an `input_iterator`?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- To provide more context, an input iterator is a type of iterator that is part of a collection/new way of organizing iterators called “[Iterator concepts](https://en.cppreference.com/w/cpp/iterator).”
	- While, I am still unsure about what the difference is between an `input_iterator` and a `output_iterator`, we need not concern ourselves for now.

⌂
<br>﹈<br>^1694722831773




﹇<br>
What type of iterator is returned when calling the method `.begin()` of a `forward_list`?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

It returns a `forward_iterator`

⌂
<br>﹈<br>^1694722831777




﹇<br>

What type of iterator can only be incremented (i.e., can not be decremented)?

#card-reverse  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

`forward_iterator`s 

Refer to the this for more information: [C++ named requirements: LegacyInputIterator - cppreference.com](https://en.cppreference.com/w/cpp/named_req/InputIterator)

⌂
<br>﹈<br>^1694722831781




﹇<br>
What are some containers that return forward iterators?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp
- `std::istream_iterator` for reading from input streams
- iterator types used by `std::forward_list`

⌂
<br>﹈<br>^1694722831785




﹇<br>
What are three types of forms of ranged-based `for` loops using the keyword `auto`?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

```cpp
// The auto keyword causes type inference to be used. Preferred. 
for( auto y : x ) { // Copy of 'x', almost always undesirable 
	cout << y << " ";
} 
cout << endl;
for( auto &y : x ) { // Type inference by reference.
	// Observes and/or modifies in-place. Preferred when modify is needed. 
	cout << y << " ";
} 
cout << endl; 
for( const auto &y : x ) { // Type inference by const reference.
	// Observes in-place. Preferred when no modify is needed.
	cout << y << " ";
}
```

⌂
<br>﹈<br>^1694722831789




﹇<br>
What is the difference between `std::numeric_limits<float>::infinity()` and `std::numeric_limits<float>::lowest()`?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

- One returns just the lowest *finite* value while the other returns a special value marked as “positive infinity.”
- Refer below to see what the console outputs when calling the command…
```bash
-3.40282e+38
inf
```

⌂
<br>﹈<br>^1694722831792




﹇<br>
What was my initial approach?

#card  #🔴-academics/📚-educational-resources/discipline/computer-science/programming-language/cpp

**Computational Complexity**:
<span class="spoiler">Time: $O(n)$</span>
<span class="spoiler">Space: $O(1)$</span>
1. <span class="spoiler">Create a variable `maxNum` that is negative infinity
	- Note that this is our “base case”, all values in our list must be equal or greater.</span>
2. <span class="spoiler">Iterate across all the elements in the container linearly
	- If `maxNum` is less than some element, maxNum is equal to that element.</span>
3. <span class="spoiler">Finish iterating and return `maxNum`</span>

⌂
<br>﹈<br>^1694722831796




#### Solution (Python)


#### Solution (JavaScript)



---

## 🔜 Next Note(s):
- [[🔴 Academics/📚 Educational Resources/🌐 Structy/0. Introduction/004. is prime 👨🏽‍💻|004. is prime 👨🏽‍💻]]

---
