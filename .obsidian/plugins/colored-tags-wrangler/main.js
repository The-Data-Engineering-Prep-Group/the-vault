/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ColoredTagWranglerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian19 = require("obsidian");

// src/settings/DefaultSettings.ts
var DefaultSettings = {
  TagColors: {
    ColorPicker: {},
    EnableMultipleTags: true,
    EnableSeparateBackground: false,
    EnableSeparateLuminanceOffset: false,
    EnableDarkLightDifference: true,
    EnableBackgroundOpacity: false,
    Values: {
      BackgroundOpacity: 0.2,
      LuminanceOffset: 0.15
    }
  },
  FolderNote: {
    Enable: false,
    FolderTagLinks: {},
    EnableAutoDetect: true,
    Values: {
      ForceImportant: true,
      BorderRadius: "12px",
      Padding: "5px"
    }
  },
  Kanban: {
    Enable: false,
    EnableCards: false,
    EnableLists: false,
    HideHashtags: false,
    Values: {
      CardBackgroundOpacity: 0.2,
      CardBorderOpacity: 0.3,
      ListBackgroundOpacity: 0.2,
      ListBorderOpacity: 0.3
    }
  },
  Debug: {
    Enable: false
  },
  Canvas: {
    Enable: false,
    Values: {
      CardBorderOpacity: 0.3,
      CardBackgroundLuminanceOffset: 0.15
    }
  },
  Info: {
    SettingsVersion: 8
    // UPDATE THIS WHEN YOU CHANGE ANYTHING IN THE SETTINGS!!!
  }
};

// src/setting_tab/SettingTab.ts
var import_obsidian18 = require("obsidian");

// src/setting_tab/SettingsTabComponent.ts
var SettingsTabComponent = class {
  // -----------------------------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------------------------
  constructor(plugin, settings_tab) {
    this.plugin = plugin;
    this.settings_tab = settings_tab;
  }
};

// src/setting_tab/components/ComponentDebug.ts
var import_obsidian = require("obsidian");
var ComponentDebug = class extends SettingsTabComponent {
  create_component(containerEL) {
    new import_obsidian.Setting(containerEL).setName("Enable debug options").setDesc(`
				Allows you to view and use some extra debug option. 
				Don't use these if you don't know what you are doing.
			`).addToggle(
      (component) => {
        component.setValue(this.plugin.settings.Debug.Enable).onChange(async (state) => {
          this.plugin.settings.Debug.Enable = state;
          await this.plugin.saveSettings();
          this.settings_tab.display();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentDebugReloadCSS.ts
var import_obsidian2 = require("obsidian");
var ComponentDebugReloadCSS = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian2.Setting(containerEL).setName("Refresh CSS styling").setDesc(`
				Reloads the styling elements of this plugin. 
				Warning: Might change order of tags in CSS and therefor chances to alter the look of certain things, 
					like the kanban boards. 
			`).addButton(
      (button) => button.setButtonText("Refresh").onClick(async () => {
        this.plugin.style_manager.switchAllStyles();
        this.settings_tab.display();
      })
    );
  }
};

// src/setting_tab/components/ComponentKanban.ts
var import_obsidian3 = require("obsidian");
var ComponentKanban = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian3.Setting(containerEL).setName("Enable Kanban integration").addToggle(
      (component) => {
        component.setValue(this.plugin.settings.Kanban.Enable).onChange(async (state) => {
          this.plugin.settings.Kanban.Enable = state;
          await this.plugin.saveSettings();
          this.settings_tab.display();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentKanbanCards.ts
var import_obsidian4 = require("obsidian");
var ComponentKanbanCards = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian4.Setting(containerEL).setName("Apply tag color to kanban card").setDesc(`
				Applies the tag color, of the tag within the card, to the background color of the card. 
				Known issue: When a card has multiple tags, the color of the card is randomly chosen.
			`).addToggle(
      (component) => {
        component.setValue(this.plugin.settings.Kanban.EnableCards).onChange(async (state) => {
          this.plugin.settings.Kanban.EnableCards = state;
          await this.plugin.saveSettings();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentKanbanLists.ts
var import_obsidian5 = require("obsidian");
var ComponentKanbanLists = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian5.Setting(containerEL).setName("Apply tag color to kanban list").setDesc(`
				Applies the tag color, of the tag within the list's title, to the background color of the list. 
				Known issue: When a list has multiple tags, the color of the list is randomly chosen.
			`).addToggle(
      (component) => {
        component.setValue(this.plugin.settings.Kanban.EnableLists).onChange(async (state) => {
          this.plugin.settings.Kanban.EnableLists = state;
          await this.plugin.saveSettings();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentTags.ts
var import_obsidian6 = require("obsidian");

// src/lib/RemoveById.ts
function removeById(id) {
  if (!id.startsWith("#")) {
    throw new DOMException("id did not start with a '#' ");
  }
  const existingStyle = document.querySelector(id);
  if (existingStyle) {
    existingStyle.remove();
  }
}

// src/lib/ColorConverters.ts
function hexToRgb(hexColor) {
  const hex = hexColor.replace("#", "");
  return {
    r: parseInt(hex.slice(0, 2), 16),
    g: parseInt(hex.slice(2, 4), 16),
    b: parseInt(hex.slice(4, 6), 16)
  };
}
function rgbToHsl(rgb) {
  const r = rgb.r / 255;
  const g = rgb.g / 255;
  const b = rgb.b / 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0;
  let s = 0;
  if (max !== min) {
    s = l > 0.5 ? (max - min) / (2 - max - min) : (max - min) / (max + min);
    if (max === r) {
      h = (60 * ((g - b) / (max - min)) + 360) % 360;
    } else if (max === g) {
      h = 60 * ((b - r) / (max - min)) + 120;
    } else {
      h = 60 * ((r - g) / (max - min)) + 240;
    }
  }
  return { h, s, l };
}
function hslToRgb(hsl) {
  const { h, s, l } = hsl;
  const normalizedHue = (h % 360 + 360) % 360;
  const normalizedSaturation = Math.max(0, Math.min(1, s));
  const normalizedLightness = Math.max(0, Math.min(1, l));
  const chroma = (1 - Math.abs(2 * normalizedLightness - 1)) * normalizedSaturation;
  const x = chroma * (1 - Math.abs(normalizedHue / 60 % 2 - 1));
  const m = normalizedLightness - chroma / 2;
  let r = 0, g = 0, b = 0;
  if (normalizedHue >= 0 && normalizedHue < 60) {
    r = chroma;
    g = x;
  } else if (normalizedHue >= 60 && normalizedHue < 120) {
    r = x;
    g = chroma;
  } else if (normalizedHue >= 120 && normalizedHue < 180) {
    g = chroma;
    b = x;
  } else if (normalizedHue >= 180 && normalizedHue < 240) {
    g = x;
    b = chroma;
  } else if (normalizedHue >= 240 && normalizedHue < 300) {
    r = x;
    b = chroma;
  } else {
    r = chroma;
    b = x;
  }
  r = Math.round((r + m) * 255);
  g = Math.round((g + m) * 255);
  b = Math.round((b + m) * 255);
  return { r, g, b };
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/setting_tab/components/ComponentTags.ts
var _NEW_TAG_NAME = "new-tag";
var _NEW_DEFAULT_COLOR = { r: 255, g: 255, b: 255 };
var _NEW_DEFAULT_BACKGROUND_COLOR = { r: 255, g: 255, b: 255 };
var ComponentTags = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    let setting = new import_obsidian6.Setting(containerEL).setName("Custom color tags").setDesc(`Define custom colors for tags.`).addButton((button) => this._add_new_tag_button(button));
    if (this.plugin.settings.Debug.Enable) {
      setting.addButton(
        (button) => button.setButtonText("Clear all").onClick(
          async () => {
            Object.keys(this.plugin.settings.TagColors.ColorPicker).forEach((key_name) => delete this.plugin.settings.TagColors.ColorPicker[key_name]);
            await Promise.all([
              this.plugin.saveSettings(),
              this.settings_tab.display()
            ]);
          }
        ).setClass("mod-warning").setDisabled(Object.keys(this.plugin.settings.TagColors.ColorPicker).length == 0)
      );
    }
    for (const tagUUID in this.plugin.settings.TagColors.ColorPicker) {
      if (!this.plugin.settings.TagColors.ColorPicker.hasOwnProperty(tagUUID)) {
        continue;
      }
      this._createTagColorSetting(tagUUID, this.plugin.settings.TagColors.ColorPicker[tagUUID], containerEL);
    }
    new import_obsidian6.Setting(containerEL).addButton((button) => this._add_new_tag_button(button));
  }
  // -----------------------------------------------------------------------------------------------------------------
  _add_new_tag_button(button) {
    button.setButtonText("Add new tag").onClick(async () => {
      this.plugin.settings.TagColors.ColorPicker[v4_default()] = {
        tag_name: _NEW_TAG_NAME,
        color: _NEW_DEFAULT_COLOR,
        // Default color
        background_color: _NEW_DEFAULT_BACKGROUND_COLOR,
        // Default color
        luminance_offset: this.plugin.settings.TagColors.Values.LuminanceOffset
      };
      await Promise.all([
        this.plugin.saveSettings(),
        this.settings_tab.display()
      ]);
    }).setClass("mod-cta");
  }
  _text_callback(text, tag_id, new_tag_content) {
    return text.setPlaceholder(_NEW_TAG_NAME).setValue(new_tag_content.tag_name).onChange(async (value) => {
      new_tag_content.tag_name = value.replace("#", "").trim();
      this.plugin.settings.TagColors.ColorPicker[tag_id] = new_tag_content;
      await this.plugin.saveSettings();
    });
  }
  _createTagColorSetting(tagUUID, tag_content, containerEL) {
    let tag_id = tagUUID;
    let new_tag_content = tag_content;
    const setting = new import_obsidian6.Setting(containerEL);
    if (this.plugin.settings.TagColors.EnableMultipleTags) {
      setting.addTextArea((text) => this._text_callback(text, tag_id, new_tag_content));
    } else {
      setting.addText((text) => this._text_callback(text, tag_id, new_tag_content));
    }
    setting.addColorPicker(
      (colorPicker) => colorPicker.setValueRgb(new_tag_content.color).onChange(async (value) => {
        new_tag_content.color = hexToRgb(value);
        if (!this.plugin.settings.TagColors.EnableSeparateBackground) {
          let hsl = rgbToHsl(new_tag_content.color);
          hsl.l -= this.plugin.settings.TagColors.Values.LuminanceOffset;
          new_tag_content.background_color = hslToRgb(hsl);
        }
        this.plugin.settings.TagColors.ColorPicker[tag_id] = new_tag_content;
        await this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.TagColors.EnableSeparateBackground) {
      setting.addColorPicker(
        (colorPicker) => colorPicker.setValueRgb(new_tag_content.background_color).onChange(async (value) => {
          new_tag_content.background_color = hexToRgb(value);
          this.plugin.settings.TagColors.ColorPicker[tag_id] = new_tag_content;
          await this.plugin.saveSettings();
        })
      );
    }
    if (this.plugin.settings.TagColors.EnableSeparateLuminanceOffset) {
      let sliderElement;
      let textElement;
      setting.addSlider(
        (component) => {
          component.setLimits(-0.5, 0.5, 0.05).setValue(this.plugin.settings.TagColors.ColorPicker[tag_id].luminance_offset).onChange(async (state) => {
            this.plugin.settings.TagColors.ColorPicker[tag_id].luminance_offset = state;
            await this.plugin.saveSettings();
            textElement.setValue(String(state));
          });
          sliderElement = component;
        }
      ).addText((text) => {
        text.setPlaceholder(this.plugin.settings.TagColors.Values.LuminanceOffset.toString()).setValue(String(this.plugin.settings.TagColors.ColorPicker[tag_id].luminance_offset)).onChange(async (state) => {
          let state_as_number = Number(state);
          if (isNaN(state_as_number) || state_as_number === null) {
            state_as_number = 0;
          }
          this.plugin.settings.TagColors.ColorPicker[tag_id].luminance_offset = state_as_number;
          await this.plugin.saveSettings();
          sliderElement.setValue(state_as_number);
        });
        textElement = text;
      });
    }
    setting.addButton(
      (button) => button.setButtonText("-").onClick(async () => {
        delete this.plugin.settings.TagColors.ColorPicker[tag_id];
        await Promise.all([
          this.plugin.saveSettings(),
          this.settings_tab.display()
        ]);
      })
    );
    containerEL.appendChild(setting.settingEl);
  }
};

// src/setting_tab/components/ComponentTagsCanvas.ts
var import_obsidian7 = require("obsidian");
var ComponentTagsCanvas = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian7.Setting(containerEL).setName("Apply tag color to canvas card").setDesc(`
			Applies the tag color, of the tag within the canvas's card, to the background color of the canvas card.
			The Value slider and setter to the right, are the luminance offsets for the background.
			`).addToggle(
      (component) => {
        component.setValue(this.plugin.settings.Canvas.Enable).onChange(async (state) => {
          this.plugin.settings.Canvas.Enable = state;
          await this.plugin.saveSettings();
          this.settings_tab.display();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentFolderNote.ts
var import_obsidian8 = require("obsidian");
var ComponentFolderNote = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian8.Setting(containerEL).setName("Enable Folder Note integration").setDesc(`
				Applies the tag color, of the tag within a Folder Note, to the background color of the folder in the file viewer.
				It is recommended that you enable 'Enable Multiple Tags' as well, to easily reuse colors for multiple folders.
				The order of these lines is important, as they influence which CSS is eventually used.
			`).addToggle(
      (component) => {
        component.setValue(this.plugin.settings.FolderNote.Enable).onChange(async (state) => {
          this.plugin.settings.FolderNote.Enable = state;
          await this.plugin.saveSettings();
          this.settings_tab.display();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentFolderNoteDetect.ts
var import_obsidian9 = require("obsidian");

// src/lib/FolderNoteLogic.ts
function getParentFolderName(filePath) {
  const pathParts = filePath.split("/");
  return pathParts[pathParts.length - 2];
}
async function processTagColors(plugin, tag_to_find) {
  var _a;
  return (_a = Object.keys(plugin.settings.TagColors.ColorPicker).filter((key) => {
    const data = plugin.settings.TagColors.ColorPicker[key];
    if (plugin.settings.TagColors.EnableMultipleTags) {
      return data.tag_name.split(";").filter((tag) => tag === tag_to_find).first();
    } else {
      return data.tag_name === tag_to_find;
    }
  }).first()) != null ? _a : null;
}
function file_is_folderNote(file) {
  return file.name.replace(".md", "") === getParentFolderName(file.path);
}
async function detect_all_links(plugin) {
  try {
    const { vault } = plugin.app;
    const markdownFiles = vault.getMarkdownFiles();
    const links = await Promise.all(
      markdownFiles.filter((file) => file_is_folderNote(file)).map(async (file) => {
        var _a, _b, _c;
        let tags = (_c = (_b = (_a = plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.tags) != null ? _c : [];
        return tags.filter(async (tag) => await processTagColors(plugin, tag)).map((tag) => ({
          tag_name: tag,
          folder_path: file.path.replace(`/${file.name}`, "")
        }));
      })
    );
    return links.flat();
  } catch (error) {
    console.error("Error in _auto_detect_links:", error);
    return [];
  }
}

// src/setting_tab/components/ComponentFolderNoteDetect.ts
var ComponentFolderNoteDetect = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian9.Setting(containerEL).setName("Detect tags in folder notes").setDesc(`Traverses your vault and stores all tags found in notes with the same name as the folder they are found in.`).addButton(
      (button) => button.setButtonText("Detect Manually").onClick(async () => {
        this.plugin.settings.FolderNote.FolderTagLinks = {};
        const found_folder_tags = await detect_all_links(this.plugin);
        found_folder_tags.sort((a, b) => a.folder_path.localeCompare(b.folder_path)).forEach((v) => {
          this.plugin.settings.FolderNote.FolderTagLinks[v4_default()] = v;
        });
        await Promise.all([
          this.plugin.saveSettings(),
          this.settings_tab.display()
        ]);
      }).setClass("mod-warning")
    );
  }
};

// src/setting_tab/components/ComponentFolderNoteFolderTagLinks.ts
var import_obsidian10 = require("obsidian");
var ComponentFolderNoteFolderTagLinks = class extends SettingsTabComponent {
  constructor() {
    super(...arguments);
    this._NEW_TAG_NAME = "undefined-tag";
    this._NEW_FOLDER_PATH = "undefined-path";
  }
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    let setting = new import_obsidian10.Setting(containerEL).setName("Top Level Folder ").setDesc(`Define custom colors for tags.`).addButton(
      (button) => button.setButtonText("Add new link").onClick(async () => {
        this.plugin.settings.FolderNote.FolderTagLinks[v4_default()] = { folder_path: this._NEW_FOLDER_PATH, tag_name: this._NEW_TAG_NAME };
        await Promise.all([
          this.plugin.saveSettings(),
          this.settings_tab.display()
        ]);
      }).setClass("mod-cta")
    );
    if (this.plugin.settings.Debug.Enable) {
      setting.addButton(
        (button) => button.setButtonText("Clear all").onClick(
          async () => {
            Object.keys(this.plugin.settings.FolderNote.FolderTagLinks).forEach((key_name) => delete this.plugin.settings.FolderNote.FolderTagLinks[key_name]);
            await Promise.all([
              this.plugin.saveSettings(),
              this.settings_tab.display()
            ]);
          }
        ).setClass("mod-warning").setDisabled(Object.keys(this.plugin.settings.FolderNote.FolderTagLinks).length == 0)
      );
    }
    for (const linkUUID in this.plugin.settings.FolderNote.FolderTagLinks) {
      if (!this.plugin.settings.FolderNote.FolderTagLinks.hasOwnProperty(linkUUID)) {
        continue;
      }
      this._createFolderTagLinks(linkUUID, this.plugin.settings.FolderNote.FolderTagLinks[linkUUID], containerEL);
    }
  }
  // -----------------------------------------------------------------------------------------------------------------
  _createFolderTagLinks(linkUUID, link_content, containerEL) {
    let link_id = linkUUID;
    let new_link_content = link_content;
    const setting = new import_obsidian10.Setting(containerEL).addText(
      (text) => text.setPlaceholder(this._NEW_TAG_NAME).setValue(new_link_content.tag_name).onChange(async (value) => {
        new_link_content.tag_name = value.replace("#", "").toLowerCase().trim();
        this.plugin.settings.FolderNote.FolderTagLinks[link_id] = new_link_content;
        await this.plugin.saveSettings();
      })
    ).addText(
      (text) => text.setPlaceholder(this._NEW_FOLDER_PATH).setValue(new_link_content.folder_path).onChange(async (value) => {
        new_link_content.folder_path = value;
        this.plugin.settings.FolderNote.FolderTagLinks[link_id] = new_link_content;
        await this.plugin.saveSettings();
      })
    ).addButton(
      (button) => button.setButtonText("-").onClick(async () => {
        delete this.plugin.settings.FolderNote.FolderTagLinks[link_id];
        await Promise.all([
          this.plugin.saveSettings(),
          this.settings_tab.display()
        ]);
      })
    );
    containerEL.appendChild(setting.settingEl);
  }
};

// src/setting_tab/components/ComponentTagsEnableMultipleTags.ts
var import_obsidian11 = require("obsidian");
var ComponentTagsEnableMultipleTags = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian11.Setting(containerEL).setName("Enable multiple tags per line").setDesc("Allows the usage of `;` or `\\n` (new line) to bind multiple tags to one color.").addToggle(
      (component) => {
        component.setValue(this.plugin.settings.TagColors.EnableMultipleTags).onChange(async (state) => {
          this.plugin.settings.TagColors.EnableMultipleTags = state;
          await this.plugin.saveSettings();
          this.settings_tab.display();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentTagsEnableSeparateBackground.ts
var import_obsidian12 = require("obsidian");
var ComponentTagsEnableSeparateBackground = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian12.Setting(containerEL).setName("Enable separate background color").setDesc("Allows you to specify a different background color for each tag.").addToggle(
      (component) => {
        component.setValue(this.plugin.settings.TagColors.EnableSeparateBackground).onChange(async (state) => {
          this.plugin.settings.TagColors.EnableSeparateBackground = state;
          await this.plugin.saveSettings();
          this.settings_tab.display();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentKanbanHideHashtags.ts
var import_obsidian13 = require("obsidian");
var ComponentKanbanHideHashtags = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian13.Setting(containerEL).setName("Omit '#' in kanban boards").setDesc(`
				Hides the '#' from the kanban view, 
					though they still have to be typed out within the used areas.
			`).addToggle(
      (component) => {
        component.setValue(this.plugin.settings.Kanban.HideHashtags).onChange(async (state) => {
          this.plugin.settings.Kanban.HideHashtags = state;
          await this.plugin.saveSettings();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentTagsEnableSeparateLuminance.ts
var import_obsidian14 = require("obsidian");
var ComponentTagsEnableSeparateLuminance = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian14.Setting(containerEL).setName("Enable separate luminance offsets per tag").setDesc("Allows you to specify a different luminance offset value for each tag. This offset is used in background of items like Canvas Card, Kanban Card/List, ...").addToggle(
      (component) => {
        component.setValue(this.plugin.settings.TagColors.EnableSeparateLuminanceOffset).onChange(async (state) => {
          this.plugin.settings.TagColors.EnableSeparateLuminanceOffset = state;
          await this.plugin.saveSettings();
          this.settings_tab.display();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentTagsEnableDarkLightDifference.ts
var import_obsidian15 = require("obsidian");
var ComponentTagsEnableDarkLightDifference = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian15.Setting(containerEL).setName("Enable different luminance formula for dark & light mode").setDesc(`
				When enabled, applies the luminance offset differently depending on Dark or Light mode.
				Formula stays the same in Dark mode, only applies to Light mode.
			`).addToggle(
      (component) => {
        component.setValue(this.plugin.settings.TagColors.EnableDarkLightDifference).onChange(async (state) => {
          this.plugin.settings.TagColors.EnableDarkLightDifference = state;
          await this.plugin.saveSettings();
        });
      }
    );
  }
};

// src/setting_tab/components/ComponentTagsEnableBackgroundOpacity.ts
var import_obsidian16 = require("obsidian");
var ComponentTagsEnableBackgroundOpacity = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    let setting = new import_obsidian16.Setting(containerEL).setName("Enable background opacity").setDesc(`
				Makes the backgrounds of any tags, Canvas cards, etc... slightly opaque.
				Recreates a pre 0.12.0 state.
			`).addToggle(
      (component) => {
        component.setValue(this.plugin.settings.TagColors.EnableBackgroundOpacity).onChange(async (state) => {
          this.plugin.settings.TagColors.EnableBackgroundOpacity = state;
          await this.plugin.saveSettings();
          await this.settings_tab.display();
        });
      }
    );
    if (this.plugin.settings.TagColors.EnableBackgroundOpacity) {
      setting.addText((text) => {
        text.setPlaceholder(this.plugin.settings.TagColors.Values.BackgroundOpacity.toString()).setValue(this.plugin.settings.TagColors.Values.BackgroundOpacity.toString()).onChange(async (state) => {
          let state_as_number = Number(state);
          if (isNaN(state_as_number) || state_as_number === null) {
            state_as_number = 0;
          }
          this.plugin.settings.TagColors.Values.BackgroundOpacity = state_as_number;
          await this.plugin.saveSettings();
        });
      });
    }
  }
};

// src/setting_tab/components/ComponentFolderNoteAutoDetect.ts
var import_obsidian17 = require("obsidian");
var ComponentFolderNoteAutoDetect = class extends SettingsTabComponent {
  // -----------------------------------------------------------------------------------------------------------------
  // methods
  // -----------------------------------------------------------------------------------------------------------------
  create_component(containerEL) {
    new import_obsidian17.Setting(containerEL).setName("Enable auto detection").setDesc("Auto detects changes in a file's property's tags and updates the file viewer.").addToggle(
      (component) => {
        component.setValue(this.plugin.settings.FolderNote.EnableAutoDetect).onChange(async (state) => {
          this.plugin.settings.FolderNote.EnableAutoDetect = state;
          await this.plugin.saveSettings();
        });
      }
    );
  }
};

// src/setting_tab/SettingTab.ts
var SettingTab = class extends import_obsidian18.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.plugin = plugin;
    this._components = {
      comp_tags: new ComponentTags(plugin, this),
      comp_tags_canvas: new ComponentTagsCanvas(plugin, this),
      comp_tags_enable_multiple_tags: new ComponentTagsEnableMultipleTags(plugin, this),
      comp_tags_enable_background: new ComponentTagsEnableSeparateBackground(plugin, this),
      comp_folder_note: new ComponentFolderNote(plugin, this),
      comp_folder_note_auto_detect: new ComponentFolderNoteAutoDetect(plugin, this),
      comp_folder_note_detect: new ComponentFolderNoteDetect(plugin, this),
      comp_folder_note_folder_tag_links: new ComponentFolderNoteFolderTagLinks(plugin, this),
      comp_kanban: new ComponentKanban(plugin, this),
      comp_kanban_cards: new ComponentKanbanCards(plugin, this),
      comp_kanban_lists: new ComponentKanbanLists(plugin, this),
      comp_kanban_hashtags: new ComponentKanbanHideHashtags(plugin, this),
      comp_debug: new ComponentDebug(plugin, this),
      comp_debug_reloadcss: new ComponentDebugReloadCSS(plugin, this),
      comp_tags_enable_luminance: new ComponentTagsEnableSeparateLuminance(plugin, this),
      comp_tags_enable_dark_light_difference: new ComponentTagsEnableDarkLightDifference(plugin, this),
      comp_tags_enable_background_opacity: new ComponentTagsEnableBackgroundOpacity(plugin, this)
    };
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("cwt-settings-tab");
    containerEl.createEl("h2", { text: "Obsidian tags" });
    containerEl.createDiv({ cls: "setting-item-description", text: `Don't add the '#' before the tag.` });
    containerEl.createDiv({ cls: "setting-item-description", text: `If you forget this, this is done in code for you, resulting in the input being changed.` });
    containerEl.createEl("br");
    this._components.comp_tags.create_component(containerEl);
    this._components.comp_tags_canvas.create_component(containerEl);
    this._components.comp_tags_enable_multiple_tags.create_component(containerEl);
    this._components.comp_tags_enable_background.create_component(containerEl);
    this._components.comp_tags_enable_luminance.create_component(containerEl);
    this._components.comp_tags_enable_dark_light_difference.create_component(containerEl);
    this._components.comp_tags_enable_background_opacity.create_component(containerEl);
    containerEl.createEl("br");
    containerEl.createEl("h2", { text: "Kanban plugin integration" });
    this._components.comp_kanban.create_component(containerEl);
    if (this.plugin.settings.Kanban.Enable) {
      this._components.comp_kanban_cards.create_component(containerEl);
      this._components.comp_kanban_lists.create_component(containerEl);
      this._components.comp_kanban_hashtags.create_component(containerEl);
    }
    containerEl.createEl("br");
    containerEl.createEl("h2", { text: "Folder Note integration" });
    containerEl.createEl("div", { cls: "setting-item-description", text: "Doesn't integrate with a particular plugin, but relies of the concept of 'Folder Notes'." });
    this._components.comp_folder_note.create_component(containerEl);
    if (this.plugin.settings.FolderNote.Enable) {
      this._components.comp_folder_note_auto_detect.create_component(containerEl);
      this._components.comp_folder_note_detect.create_component(containerEl);
      this._components.comp_folder_note_folder_tag_links.create_component(containerEl);
    }
    containerEl.createEl("br");
    containerEl.createEl("h2", { text: "Debug options" });
    this._components.comp_debug.create_component(containerEl);
    if (this.plugin.settings.Debug.Enable) {
      this._components.comp_debug_reloadcss.create_component(containerEl);
    }
  }
};

// src/style_manager/wranglers/StyleWrangler.ts
var StyleWrangler = class {
  // -----------------------------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------------------------
  constructor(id, plugin) {
    !id.startsWith("#") ? id = `#${id}` : null;
    this.id = id;
    this.plugin = plugin;
    this.styleEL_light = document.createElement("style");
    this.styleEL_dark = document.createElement("style");
    this.styleEL_light.id = `${this.id}_light`;
    this.styleEL_dark.id = `${this.id}_dark`;
  }
  // -----------------------------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------------------------
  apply_styles() {
    this.remove_styles();
    this.styleEL_light.innerText = this.assemble_css_light().map((line) => line.split("\n").map((l) => l.trim()).join(" ")).join(" ");
    this.styleEL_dark.innerText = this.assemble_css_dark().map((line) => line.split("\n").map((l) => l.trim()).join(" ")).join(" ");
    document.head.appendChild(this.styleEL_light);
    document.head.appendChild(this.styleEL_dark);
  }
  remove_styles() {
    var _a, _b, _c, _d;
    (_b = (_a = this.styleEL_light) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(this.styleEL_light);
    (_d = (_c = this.styleEL_dark) == null ? void 0 : _c.parentNode) == null ? void 0 : _d.removeChild(this.styleEL_dark);
    removeById(this.id);
  }
  get_tags() {
    var _a;
    return Object.keys((_a = this.plugin.settings) == null ? void 0 : _a.TagColors.ColorPicker).map((tagUUID) => {
      var _a2;
      const { tag_name, color, background_color, luminance_offset } = this.plugin.settings.TagColors.ColorPicker[tagUUID];
      if ((_a2 = this.plugin.settings) == null ? void 0 : _a2.TagColors.EnableMultipleTags) {
        return tag_name.split(/[\n;]/).filter((tag) => tag).map(
          (tag) => (
            // Also trim the tag for leading spaces after or before a \n? Should fix some common issues.
            { tag_name: tag.trim(), color, background_color, luminance_offset }
          )
        );
      } else {
        return { tag_name, color, background_color, luminance_offset };
      }
    }).flat();
  }
  get_background_color(background_color, luminance_offset, is_light_theme) {
    if (is_light_theme && this.plugin.settings.TagColors.EnableDarkLightDifference) {
      luminance_offset = -luminance_offset;
    }
    let background_hsl = rgbToHsl(background_color);
    background_hsl.l -= luminance_offset;
    return hslToRgb(background_hsl);
  }
  get_background_string(color) {
    const rgb = this.plugin.settings.TagColors.EnableBackgroundOpacity ? "rgba" : "rgb";
    const opacity = this.plugin.settings.TagColors.EnableBackgroundOpacity ? `, ${this.plugin.settings.TagColors.Values.BackgroundOpacity}` : "";
    return `${rgb}(${color.r}, ${color.g}, ${color.b}${opacity})`;
  }
  get_important() {
    return this.plugin.settings.FolderNote.Values.ForceImportant ? "!important" : "";
  }
};

// src/style_manager/wranglers/StyleWranglerKanbanHashtags.ts
var StyleWranglerKanbanHashtags = class extends StyleWrangler {
  // -----------------------------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------------------------
  constructor(plugin) {
    super("#styleKanbanEl", plugin);
  }
  // -----------------------------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------------------------
  assemble_css_light() {
    return [this.assemble_css()];
  }
  assemble_css_dark() {
    return [this.assemble_css()];
  }
  assemble_css() {
    return `
		div[data-type="kanban"] a.tag>span,
		div.kanban-plugin a.tag>span,
		div[data-type="kanban"] .cm-hashtag-begin {
			visibility: hidden;
			position: absolute;
		}`;
  }
};

// src/style_manager/wranglers/StyleWranglerKanbanCards.ts
var StyleWranglerKanbanCards = class extends StyleWrangler {
  // -----------------------------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------------------------
  constructor(plugin) {
    super("#styleKanbanCardsEl", plugin);
  }
  // -----------------------------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------------------------
  assemble_css_light() {
    return this.get_tags().map(
      ({ tag_name, color, background_color, luminance_offset }) => {
        return this.assemble_css(
          "body.theme-light",
          tag_name,
          color,
          this.get_background_color(
            background_color,
            luminance_offset,
            true
          )
        );
      }
    );
  }
  assemble_css_dark() {
    return this.get_tags().map(
      ({ tag_name, color, background_color, luminance_offset }) => {
        return this.assemble_css(
          "body.theme-dark",
          tag_name,
          color,
          this.get_background_color(
            background_color,
            luminance_offset,
            false
          )
        );
      }
    );
  }
  assemble_css(theme, tag_name, color, background_color) {
    const important = this.get_important();
    return `
${theme} div.kanban-plugin__item.has-tag-${tag_name} div.kanban-plugin__item-title-wrapper { 
	background: ${this.get_background_string(background_color)} ${important};
}
${theme} div.kanban-plugin__item.has-tag-${tag_name}{ 
	border-color: rgba(${color.r}, ${color.g}, ${color.b},0.3) ${important};
}`;
  }
};

// src/style_manager/wranglers/StyleWranglerKanbanLists.ts
var StyleWranglerKanbanLists = class extends StyleWrangler {
  // -----------------------------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------------------------
  constructor(plugin) {
    super("#styleKanbanListsEl", plugin);
  }
  // -----------------------------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------------------------
  assemble_css_light() {
    return this.get_tags().map(
      ({ tag_name, color, background_color, luminance_offset }) => {
        return this.assemble_css(
          "body.theme-light",
          tag_name,
          color,
          this.get_background_color(
            background_color,
            luminance_offset,
            true
          )
        );
      }
    );
  }
  assemble_css_dark() {
    return this.get_tags().map(
      ({ tag_name, color, background_color, luminance_offset }) => {
        return this.assemble_css(
          "body.theme-dark",
          tag_name,
          color,
          this.get_background_color(
            background_color,
            luminance_offset,
            false
          )
        );
      }
    );
  }
  assemble_css(theme, tag_name, color, background_color) {
    const important = this.get_important();
    return `
${theme} div.kanban-plugin__lane:has(div.kanban-plugin__lane-title-text a[href="#${tag_name}"]){
	background: ${this.get_background_string(background_color)} ${important};
	border-color: rgba(${color.r}, ${color.g}, ${color.b},0.3) ${important};
}
${theme} div.kanban-plugin__lane-header-wrapper:has(div.kanban-plugin__lane-title-text a[href="#${tag_name}"]){
	border-color: rgba(${color.r}, ${color.g}, ${color.b},0.3) ${important};
}`;
  }
};

// src/style_manager/wranglers/StyleWranglerTags.ts
var StyleWranglerTags = class extends StyleWrangler {
  // -----------------------------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------------------------
  constructor(plugin) {
    super("#styleTagsEl", plugin);
  }
  // -----------------------------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------------------------
  assemble_css_light() {
    return this.get_tags().map(
      ({ tag_name, color, background_color }) => this.assemble_css(
        "body.theme-light",
        tag_name,
        color,
        background_color
      )
    );
  }
  assemble_css_dark() {
    return this.get_tags().map(
      ({ tag_name, color, background_color }) => this.assemble_css(
        "body.theme-dark",
        tag_name,
        color,
        background_color
      )
    );
  }
  assemble_css(theme, tag_name, color, background_color) {
    const important = this.get_important();
    return ` 
${theme} .tag[href="#${tag_name}"], 
${theme} .cm-tag-${tag_name} { 
	color: rgb(${color.r}, ${color.g}, ${color.b}) ${important};
	background-color: ${this.get_background_string(background_color)} ${important};
}
`;
  }
};

// src/style_manager/wranglers/StyleWranglerTagsCanvas.ts
var StyleWranglerTagsCanvas = class extends StyleWrangler {
  // -----------------------------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------------------------
  constructor(plugin) {
    super("#styleTagsCanvasEl", plugin);
  }
  // -----------------------------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------------------------
  assemble_css_light() {
    return this.get_tags().map(
      ({ tag_name, color, background_color, luminance_offset }) => {
        return this.assemble_css(
          "body.theme-light",
          tag_name,
          color,
          this.get_background_color(
            background_color,
            luminance_offset,
            true
          )
        );
      }
    );
  }
  assemble_css_dark() {
    return this.get_tags().map(
      ({ tag_name, color, background_color, luminance_offset }) => {
        return this.assemble_css(
          "body.theme-dark",
          tag_name,
          color,
          this.get_background_color(
            background_color,
            luminance_offset,
            false
          )
        );
      }
    );
  }
  assemble_css(theme, tag_name, color, background_color) {
    const important = this.get_important();
    return `
${theme} div.canvas-node-container:has(div.markdown-embed-content a[href="#${tag_name}"]) {
	background : ${this.get_background_string(background_color)} ${important};
	border-color: rgb(${color.r}, ${color.g}, ${color.b}) ${important};
}`;
  }
};

// src/style_manager/wranglers/StyleWranglerFolderNote.ts
var StyleWranglerFolderNote = class extends StyleWrangler {
  // -----------------------------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------------------------
  constructor(plugin) {
    super("#styleFolderNoteEl", plugin);
  }
  // -----------------------------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------------------------
  assemble_css_light() {
    const all_tags = this.get_tags();
    const border_radius = this.plugin.settings.FolderNote.Values.BorderRadius;
    const padding = this.plugin.settings.FolderNote.Values.Padding;
    return Object.keys(this.plugin.settings.FolderNote.FolderTagLinks).map(
      (folderUUID) => {
        const { folder_path, tag_name: folder_tag_name } = this.plugin.settings.FolderNote.FolderTagLinks[folderUUID];
        return all_tags.filter(({ tag_name: known_tag }) => known_tag === folder_tag_name).map(({ color, background_color, luminance_offset }) => {
          return this.assemble_css(
            "body.theme-light",
            folder_path,
            color,
            this.get_background_color(
              background_color,
              luminance_offset,
              true
            ),
            border_radius,
            padding
          );
        });
      }
    ).flat();
  }
  assemble_css_dark() {
    let all_tags = this.get_tags();
    let border_radius = this.plugin.settings.FolderNote.Values.BorderRadius;
    let padding = this.plugin.settings.FolderNote.Values.Padding;
    return Object.keys(this.plugin.settings.FolderNote.FolderTagLinks).map(
      (folderUUID) => {
        let { folder_path, tag_name: folder_tag_name } = this.plugin.settings.FolderNote.FolderTagLinks[folderUUID];
        return all_tags.filter(({ tag_name: known_tag }) => known_tag === folder_tag_name).map(({ color, background_color, luminance_offset }) => {
          return this.assemble_css(
            "body.theme-dark",
            folder_path,
            color,
            this.get_background_color(
              background_color,
              luminance_offset,
              false
            ),
            border_radius,
            padding
          );
        });
      }
    ).flat();
  }
  assemble_css(theme, folder_path, color, background, border_radius, padding) {
    const important = this.get_important();
    return `
/* Apply color to drop down triangle */
${theme} .nav-folder:has(> [data-path="${folder_path}"]) svg.svg-icon.right-triangle{
	stroke: rgb(${color.r}, ${color.g}, ${color.b}) ${important}; 
}

/* Applies color to the title of the folder*/
${theme} .nav-folder.alx-folder-with-note:has(> [data-path="${folder_path}"]) > .nav-folder-title > .nav-folder-title-content,
${theme} .nav-folder:has(> [data-path="${folder_path}"]) .nav-folder-title-content{
	text-decoration-color: rgba(${color.r}, ${color.g}, ${color.b},  0.6) ${important};
	text-decoration-thickness: 2px;
	color: rgb(${color.r}, ${color.g}, ${color.b}) ${important};
}

/* Applies color to the title of the file*/
${theme} .nav-folder:has(> [data-path="${folder_path}"]) .nav-file-title-content{
	color: rgb(${color.r}, ${color.g}, ${color.b}) ${important};
}

/* Applies color to the bar next to the notes in the folder*/
${theme} .nav-folder:has(> [data-path="${folder_path}"]) .nav-folder-children {
	border-left-color: rgba(${color.r}, ${color.g}, ${color.b}, 0.2) ${important};
	border-left-width: 2px ${important};
}

/* Apply color to folder title and background*/
${theme} .nav-folder:has(> [data-path="${folder_path}"]){
	background-color: ${this.get_background_string(background)} ${important};								
	border-radius: ${border_radius};
	padding: ${padding};
	margin-bottom: ${padding};
}`;
  }
};

// src/style_manager/StyleManager.ts
var StyleManager = class {
  // -----------------------------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------------------------
  constructor(plugin) {
    this.plugin = plugin;
    this.wrangler_tags = new StyleWranglerTags(plugin);
    this.wrangler_tags_canvas = new StyleWranglerTagsCanvas(plugin);
    this.wrangler_kanban_hashtags = new StyleWranglerKanbanHashtags(plugin);
    this.wrangler_kanban_cards = new StyleWranglerKanbanCards(plugin);
    this.wrangler_kanban_lists = new StyleWranglerKanbanLists(plugin);
    this.wrangler_folder_note = new StyleWranglerFolderNote(plugin);
    this._style_wranglers = new Array(
      this.wrangler_tags,
      this.wrangler_tags_canvas,
      this.wrangler_kanban_hashtags,
      this.wrangler_kanban_cards,
      this.wrangler_kanban_lists,
      this.wrangler_folder_note
    );
  }
  // -----------------------------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------------------------
  switchAllStyles() {
    Object.keys(this.plugin.settings.TagColors.ColorPicker).length != 0 ? this.wrangler_tags.apply_styles() : this.wrangler_tags.remove_styles();
    this.plugin.settings.Canvas.Enable ? this.wrangler_tags_canvas.apply_styles() : this.wrangler_tags_canvas.remove_styles();
    this.plugin.settings.Kanban.HideHashtags ? this.wrangler_kanban_hashtags.apply_styles() : this.wrangler_kanban_hashtags.remove_styles();
    this.plugin.settings.Kanban.EnableCards ? this.wrangler_kanban_cards.apply_styles() : this.wrangler_kanban_cards.remove_styles();
    this.plugin.settings.Kanban.EnableLists ? this.wrangler_kanban_lists.apply_styles() : this.wrangler_kanban_lists.remove_styles();
    this.plugin.settings.FolderNote.Enable ? this.wrangler_folder_note.apply_styles() : this.wrangler_folder_note.remove_styles();
  }
  // -----------------------------------------------------------------------------------------------------------------
  // applyAllStyles():void {
  // 	this._style_wranglers.forEach(value => {value.apply_styles()});
  // }
  // -----------------------------------------------------------------------------------------------------------------
  removeAllStyles() {
    this._style_wranglers.forEach((value) => {
      value.remove_styles();
    });
  }
};

// src/settings/migrations/migrate_0_to_1.ts
function migrate_0_to_1(loaded_data) {
  let original_colored_tags = loaded_data.TagColors.ColorPicker;
  let transformedColoredTags = {};
  for (const key of Object.keys(original_colored_tags)) {
    const originalData = original_colored_tags[key];
    transformedColoredTags[v4_default()] = {
      tag_name: key,
      // You can set the 'tag_name' as the key
      color: originalData
    };
  }
  let transformed_data = loaded_data;
  transformed_data.TagColors.ColorPicker = transformedColoredTags;
  transformed_data.Info.SettingsVersion = 1;
  return transformed_data;
}

// src/settings/migrations/migrate_1_to_2.ts
function migrate_1_to_2(loaded_data) {
  let original_semantic_tags = loaded_data.TagColors.SemanticObsidianColors;
  let transformed_semantic_tags = {};
  for (const key of Object.keys(original_semantic_tags)) {
    const originalData = original_semantic_tags[key];
    transformed_semantic_tags[v4_default()] = {
      tag_name: key,
      // You can set the 'tag_name' as the key
      obsidian_css_var: originalData
    };
  }
  let original_css_var_tags = loaded_data.TagColors.CssVars;
  let transformed_css_var_tags = {};
  for (const key of Object.keys(original_css_var_tags)) {
    const originalData = original_css_var_tags[key];
    transformed_css_var_tags[v4_default()] = {
      tag_name: key,
      // You can set the 'tag_name' as the key
      color: originalData.color,
      background: originalData.background
    };
  }
  let transformed_data = loaded_data;
  transformed_data.TagColors.SemanticObsidianColors = transformed_semantic_tags;
  transformed_data.TagColors.CssVars = transformed_css_var_tags;
  transformed_data.Info.SettingsVersion = 2;
  return transformed_data;
}

// src/settings/migrations/migrate_2_to_3.ts
function migrate_2_to_3(loaded_data) {
  let transformed_data = loaded_data;
  transformed_data.Info.SettingsVersion = 3;
  return transformed_data;
}

// src/settings/migrations/migrate_3_to_4.ts
function migrate_3_to_4(loaded_data) {
  let transformed_data = loaded_data;
  transformed_data.TagColors = {
    ColorPicker: loaded_data.TagColors.ColorPicker,
    EnableMultipleTags: loaded_data.TagColors.EnableMultipleTags,
    Values: loaded_data.TagColors.Values
  };
  transformed_data.FolderNote.Values = {
    ForceImportant: true,
    BorderRadius: "12px",
    Padding: "5px"
  };
  transformed_data.Info.SettingsVersion = 4;
  return transformed_data;
}

// src/settings/migrations/migrate_4_to_5.ts
function migrate_4_to_5(loaded_data) {
  let transformed_data = loaded_data;
  for (const tagUUID of Object.keys(loaded_data.TagColors.ColorPicker)) {
    transformed_data.TagColors.ColorPicker[tagUUID] = {
      tag_name: loaded_data.TagColors.ColorPicker[tagUUID].tag_name,
      color: loaded_data.TagColors.ColorPicker[tagUUID].color,
      background_color: loaded_data.TagColors.ColorPicker[tagUUID].color,
      background_opacity: 0.2
    };
  }
  transformed_data.Info.SettingsVersion = 5;
  return transformed_data;
}

// src/settings/migrations/migrate_5_to_6.ts
function migrate_5_to_6(loaded_data) {
  let transformed_data = loaded_data;
  transformed_data.Kanban.HideHashtags = loaded_data.Kanban.Enable;
  transformed_data.Info.SettingsVersion = 6;
  return transformed_data;
}

// src/settings/migrations/migrate_6_to_7.ts
function migrate_6_to_7(loaded_data) {
  let transformed_data = loaded_data;
  transformed_data.TagColors.Values.LuminanceOffset = 0.15;
  transformed_data.TagColors.EnableSeparateLuminanceOffset = false;
  transformed_data.TagColors.EnableDarkLightDifference = true;
  transformed_data.TagColors.EnableBackgroundOpacity = false;
  transformed_data.TagColors.Values.BackgroundOpacity = 0.2;
  for (const tagUUID of Object.keys(loaded_data.TagColors.ColorPicker)) {
    let old_record = loaded_data.TagColors.ColorPicker[tagUUID];
    transformed_data.TagColors.ColorPicker[tagUUID] = {
      tag_name: old_record.tag_name,
      color: old_record.color,
      background_color: checkColor(old_record.background_color, old_record.color) ? callback_fix_background(old_record.background_color, transformed_data.TagColors.Values.LuminanceOffset) : old_record.background_color,
      luminance_offset: transformed_data.TagColors.Values.LuminanceOffset
    };
  }
  transformed_data.Info.SettingsVersion = 7;
  return transformed_data;
}
function checkColor(color, background) {
  let check = color.r === background.r && color.g === background.g && color.b === background.b;
  console.warn({ color, background, check });
  return check;
}
function callback_fix_background(background, luminance_offset) {
  let background_hsl = rgbToHsl(background);
  background_hsl.l -= luminance_offset;
  return hslToRgb(background_hsl);
}

// src/settings/migrations/migrate_7_to_8.ts
function migrate_7_to_8(loaded_data) {
  let transformed_data = loaded_data;
  transformed_data.FolderNote.EnableAutoDetect = true;
  transformed_data.Info.SettingsVersion = 8;
  return transformed_data;
}

// src/settings/Migrate.ts
var MIGRATION_STEPS = [
  // Using any's isn't perfect but will do for now
  // Add more lambdas in order.
  //      Btw this only works because I smart enough to start from 0,
  //      that way I don't need to do any other steps in the for loop
  (data) => migrate_0_to_1(data),
  (data) => migrate_1_to_2(data),
  (data) => migrate_2_to_3(data),
  (data) => migrate_3_to_4(data),
  (data) => migrate_4_to_5(data),
  (data) => migrate_5_to_6(data),
  (data) => migrate_6_to_7(data),
  (data) => migrate_7_to_8(data)
];
function Migrate(data) {
  var _a, _b;
  if (data === null) {
    return null;
  }
  let version = (_b = (_a = data == null ? void 0 : data.Info) == null ? void 0 : _a.SettingsVersion) != null ? _b : -1;
  if (version === -1) {
    console.warn("Version could not be established, assigning as is. Please data.json.");
    return data;
  }
  let migratedData = data;
  for (version; version < MIGRATION_STEPS.length; version++) {
    migratedData = MIGRATION_STEPS[version](migratedData);
    console.log(`Migrated data.json from ColoredTagsWrangler to version ${migratedData.Info.SettingsVersion}`);
  }
  return migratedData;
}

// src/event_handlers/EventHandlerMetadataChange.ts
var EventHandlerMetadataChange = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  register() {
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on(
        "changed",
        async (file, __, cache) => {
          if (this.plugin.settings.FolderNote.Enable && this.plugin.settings.FolderNote.EnableAutoDetect) {
            await this.callback(file, cache);
          }
        }
      )
    );
  }
  async callback(file, cache) {
    var _a;
    const folder_path = file.path.replace(`/${file.name}`, "");
    const tags = (_a = cache.frontmatter) == null ? void 0 : _a.tags;
    if (!file_is_folderNote(file) || tags === void 0) {
      return;
    }
    const linksToKeep = Object.values(this.plugin.settings.FolderNote.FolderTagLinks).filter((link) => link.folder_path !== folder_path);
    const newLinks = tags.map((tag) => tag.replace("#", "")).filter((tag) => processTagColors(this.plugin, tag)).map((tag) => ({
      tag_name: tag,
      folder_path
    }));
    this.plugin.settings.FolderNote.FolderTagLinks = {};
    const updatedLinks = [...linksToKeep, ...newLinks];
    updatedLinks.sort((a, b) => a.folder_path.localeCompare(b.folder_path)).forEach((link) => {
      this.plugin.settings.FolderNote.FolderTagLinks[v4_default()] = link;
    });
    await this.plugin.saveSettings();
  }
};

// src/main.ts
var ColoredTagWranglerPlugin = class extends import_obsidian19.Plugin {
  // -----------------------------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------------------------
  async onload() {
    try {
      await this.loadSettings();
    } catch (error) {
      console.error("Error loading setting_tab for obsidian-colored_tags_wrangler:", error);
      return;
    }
    this.style_manager = new StyleManager(this);
    this.addSettingTab(new SettingTab(this));
    this.style_manager.switchAllStyles();
    new EventHandlerMetadataChange(this).register();
  }
  // -----------------------------------------------------------------------------------------------------------------
  onunload() {
    this.style_manager.removeAllStyles();
  }
  // -----------------------------------------------------------------------------------------------------------------
  async loadSettings() {
    this.settings = Object.assign({}, DefaultSettings, Migrate(await this.loadData()));
    await this.saveData(this.settings);
  }
  // -----------------------------------------------------------------------------------------------------------------
  async saveSettings() {
    await this.saveData(this.settings);
    this.style_manager.switchAllStyles();
  }
};
