---
title: "1. Array and String"
created: 2023-08-04 01:58 
authors: [Edmund Leibert III]
tags: [educational-resource/structy, study-note]
cards-deck: Default::Computer Science
---

# 🌐 Structy

## 1. Array and String

### 005. array and string welcome 👨🏻‍🏫

![[structy-array-and-string-welcome.mp4|150]]

#### Solution (C++)

##### Attempt #1 (2022-22-07) ⏲️ 00:04:00

What is the two pointer method? 
#card  #computer-science/programming-language/cpp
- The two pointer is a common method for easily finding a subsegment of a larger segment.
- Generally, it has a time complexity of $\mathcal{O}(n)$
^1687765735569


What is a hash map? 
#card  #computer-science/programming-language/cpp
- As associative container in which each element is a pair with the pair being represented by either a key or a value.
^1687765735577


What is hash set? 
#card  #computer-science/programming-language/cpp
- A hash set is essentially just a container that can only contain unique elements.
^1687765735584

What is the difference between hash map and hash set? 
#card  #computer-science/programming-language/cpp
Here’s an example in C++ that demonstrates the difference between a hash map and a hash set:
```cpp
#include <iostream>
#include <unordered_map>
#include <unordered_set>
int main() {
    // Create a hash map with string keys and int values
    std::unordered_map<std::string, int> map;
    map["apple"] = 1;
    map["banana"] = 2;
    map["orange"] = 3;
    // Print the key-value pairs in the hash map
    std::cout << "Hash map:" << std::endl;
    for (const auto& pair : map) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    // Create a hash set with string elements
    std::unordered_set<std::string> set;
    set.insert("apple");
    set.insert("banana");
    set.insert("orange");
    // Print the elements in the hash set
    std::cout << "Hash set:" << std::endl;
    for (const auto& element : set) {
        std::cout << element << std::endl;
    }
    return 0;
}
```
This code creates a hash map with string keys and int values, and inserts three key-value pairs into the map. It then creates a hash set with string elements, and inserts three elements into the set. Finally, it prints the contents of both the hash map and the hash set.
The output of this code might look like this:
```
Hash map:
banana: 2
orange: 3
apple: 1
Hash set:
banana
orange
apple
```
As you can see, the hash map stores key-value pairs, while the hash set stores only unique elements. 
^1690066826942

### 006. uncompress 💻

#### Solution (C++)

##### Attempt #1 (2023-25-06) ⏲️ 00:08:00


What was my initial approach to solving this problem? 
#card  #computer-science/programming-language/cpp
- Iterate across the input string
- If the current char is *not* a char, push the assumed `int` into a “numbers” string
- If a char, append the char “numbers” amount of times to the result.  Reset numbers.
- Example code below...
```cpp
#include <string>
std꞉꞉string uncompress(std꞉꞉string s) {
  // todo
  std꞉꞉string result = "";
  std꞉꞉string patternLength = "";
  int length {0};
  for(int i{0}; i < s.length(); i++) {
    if(isdigit(s.at(i))) { // if digit, append
      patternLength.push_back(s.at(i));
    }
    else { //if not a digit
      length = std꞉꞉stoi(patternLength);
      while(length > 0) {
        result.push_back(s.at(i));
        length--;
      }
      patternLength = "";
      length = 0;
    }
  }
  return result;
}
void run() {
  // this function behaves as `main()` for the 'run' command
  // you may sandbox in this function, but should not remove it
}
```
^1687765735590


What was wrong with my initial approach? 
#card  #computer-science/programming-language/cpp
While correct, takes a little too long and does not the *two pointer* method.
^1687765735596


What is the difference between using indexing (i.e. brackets) to access the position of a string vs using the `at()` method in C++? 
#card  #computer-science/programming-language/cpp
- The main difference between using indexing (`[]`) and the `at()` method to access a character in a string in C++ is that the `at()` method performs bounds checking and throws an exception if the index provided is out of bounds ³. On the other hand, using indexing (`[]`) to access an out-of-bounds index results in undefined behavior ⁴.
- In summary, using the `at()` method is safer because it will throw an exception if you try to access an out-of-bounds index, while using indexing (`[]`) can result in undefined behavior if you accidentally access an out-of-bounds index ⁵.
- **Source**: Conversation with Bing, 6/23/2023
  (1) c++ - Difference between std꞉꞉string - Stack Overflow. https://stackoverflow.com/questions/50687711/difference-between-stdstring-operator-and-at.
  (2) How to access an element of a vector using index in C++. https://www.codevscolor.com/c-plus-plus-access-element-of-vector.
  (3) c++ - What is the difference between string꞉꞉at and string꞉꞉operator .... https://stackoverflow.com/questions/14699060/what-is-the-difference-between-stringat-and-stringoperator.
  (4) c++ - vector꞉꞉at vs. vector꞉꞉operator[] - Stack Overflow. https://stackoverflow.com/questions/9376049/vectorat-vs-vectoroperator.
  (5) string at() in C++ - GeeksforGeeks. https://www.geeksforgeeks.org/string-at-in-cpp/.
^1687765735602


##### Attempt #2 (2023-25-06) ⏲️ 00:08:00

Lets lets consider the case that I have two pointers pointing to the 2nd and 5th position of a string. With the two pointers, how can I get the character width between these two? For instance, in this case, the character width between these two pointers would be 4 (we are excluding the 5th position). 
#card  #computer-science/programming-language/cpp
Yes, in modern C++, you can use the `std꞉꞉distance` function from the `<iterator>` header to calculate the distance between two iterators or pointers. Here's an updated example using `std꞉꞉distance`: 
```cpp
#include <iostream>
#include <string>
#include <iterator>
int main() {
    std꞉꞉string str = "Hello, World!";
    auto ptr1 = std꞉꞉next(str.begin(), 1);  // Iterator to the 2nd position
    auto ptr2 = std꞉꞉next(str.begin(), 4);  // Iterator to the 5th position
    int width = std꞉꞉distance(ptr1, ptr2);
    std꞉꞉cout << "Character width: " << width << std꞉꞉endl;
    return 0;
}
```
In this example, `std꞉꞉next` is used to obtain iterators pointing to the desired positions in the string. Then, `std꞉꞉distance` is used to calculate the distance between these iterators, which gives us the character width between the two positions. The output will still be 4, indicating the number of characters between the 2nd and 5th positions (excluding the 5th position).
^1687765735608


What function in C++ can I use to get a **substring** of a string if I just have the positions represented as `int`s? 
#card  #computer-science/programming-language/cpp
- In C++, you can use the `substr` function to extract a part of a string. The `substr` function takes two arguments: the starting position (index) of the substring and the length of the substring. Here's an example:
	```cpp
	#include <iostream>
	#include <string>
	int main() {
	    std꞉꞉string str = "Hello, World!";
	    // Extract a substring starting from position 7 with length 5
	    std꞉꞉string substring = str.substr(7, 5);
	    std꞉꞉cout << "Substring: " << substring << std꞉꞉endl;
	    return 0;
	}
	```
- In this example, `str` is the original string, and we want to extract a substring starting from position 7 (inclusive) with a length of 5 characters. The resulting substring is "World". The `substr` function returns a new string containing the extracted part.
- Note that string indexing in C++ starts from 0, so the first character of the string is at index 0. The extracted substring includes the starting position and continues for the specified length.
- You need to include the `<string>` header to use the `substr` function.
^1687765735613


What function in C++ can I use to get a **substring** of a string if I just have the positions represented as pointers? 
#card  #computer-science/programming-language/cpp
- Should use the `string()` function as seen below to just build a new string…
	```cpp
	std꞉꞉string uncompress(std꞉꞉string s) {
	    // todo
	    const char* frontPtr = &s[0];
	    const char* backPtr = &s[0];
	    int dis {0};
	    std꞉꞉string result = "";
	    while(*frontPtr != '\0') {
	        // if a char, sue to create the group to append to result
	        if(isalpha(*frontPtr)) {
	            // Get the group length
	            dis = std꞉꞉stoi(std꞉꞉string(backPtr,frontPtr));
	            while(dis != 0) {
	                result.push_back(*frontPtr);
	                dis--;
	            }
	            dis = 0;
	            backPtr = frontPtr + 1;
	        }
	        frontPtr++;
	    }
	    return result;
	}
	```
- Done!
^1687765735620

How can I check if a character is a letter in C++? 
#card  #computer-science/programming-language/cpp
- To check if a character is a letter in C++, you can use the `std꞉꞉isalpha` function from the `<cctype>` header. Here's an example: 
	```cpp
	#include <iostream>
	#include <cctype>
	int main() {
	    char ch = 'A';
	    if (std꞉꞉isalpha(ch)) {
	        std꞉꞉cout << "The character is a letter." << std꞉꞉endl;
	    } else {
	        std꞉꞉cout << "The character is not a letter." << std꞉꞉endl;
	    }
	    return 0;
	}
	```
- In this example, the `isalpha` function is used to check if the character `ch` is a letter. If it is, the program outputs "The character is a letter." Otherwise, it outputs "The character is not a letter."
- Make sure to include the `<cctype>` header and prefix the `isalpha` function with `std꞉꞉` since it is defined within the `std` namespace. 
^1687765735626

When should I use **string** instead of **stringstream**? 
#card  #computer-science/programming-language/cpp
- If you're only concatenating strings use `string꞉꞉append` (or [`string꞉꞉operator+=`](http://en.cppreference.com/w/cpp/string/basic_string/operator+=)).
- If you're going to convert numbers to their string representation, as well as format them during conversion, and then append the conversion results together, use stringstreams. I mention the formatting part explicitly because if you do not require formatting C++11 offers [`std꞉꞉to_string`](http://en.cppreference.com/w/cpp/string/basic_string/to_string) which can be used to convert numeric types to strings.
  For example, refer to how the code is used below…
	```cpp
	#include <sstream>
	#include <cctype>
	std꞉꞉string uncompress(const std꞉꞉string& s) {
	    std꞉꞉stringstream ss;
	    std꞉꞉string result;
	    for(auto it = s.begin(); it != s.end(); ++it) {
	        if(std꞉꞉isdigit(*it)) {
	            ss << *it;
	        } else if(std꞉꞉isalpha(*it)) {
	            int count = 0;
	            ss >> count;
	            result.append(count, *it); // append *it 'count' times to result
	            ss.clear(); // clear the stringstream for next number
	        }
	    }
	    return result;
	}
	```
- Done!
^1687765735631

What is the difference between `string.append()` and `string.push_back()` in C++? 
#card  #computer-science/programming-language/cpp
- `std꞉꞉string꞉꞉append` and `std꞉꞉string꞉꞉push_back` are both used to append characters to a string in C++. The difference between them lies in their implementation and application. `std꞉꞉string꞉꞉append` lets you specify the appended value by using multiple arguments and has a time complexity of O(n). On the other hand, `std꞉꞉string꞉꞉push_back` lets you append a single character at a time and has a time complexity of O(1)¹.
- For example, you can append a full string using `std꞉꞉string꞉꞉append`, but you cannot do so using `std꞉꞉string꞉꞉push_back`. Similarly, you can append part of a string using `std꞉꞉string꞉꞉append`, but you cannot do so using `std꞉꞉string꞉꞉push_back`¹.
- **Source**: Conversation with Bing, 6/26/2023
  (**1**) std꞉꞉string꞉꞉append vs std꞉꞉string꞉꞉push_back() vs Operator += in C++. https://www.geeksforgeeks.org/stdstringappend-vs-stdstringpush_back-vs-operator-c/.
  (**2**) C++ Question about .append () vs .push_back () for Strings and .... https://stackoverflow.com/questions/76518863/c-question-about-append-vs-push-back-for-strings-and-characters-beginne.
  (**3**) std꞉꞉string꞉꞉push_back() in C++ - GeeksforGeeks. https://www.geeksforgeeks.org/stdstringpush_back-in-cpp/.
^1687766251956

In C++, how can I specify I wish to append a character `count` times? 
#card  #computer-science/programming-language/cpp
```cpp
result.append(count, *it) // append *it 'count' times to result
```
^1687766382335

In C++, how can I create a `std꞉꞉string` that contains ‘y’ 127 times? 
#card
 #computer-science/programming-language/cpp```cpp
std꞉꞉string expected_result(127, 'y'); // this creates a string of 127 'y's
```
^1687766504192

In C++, how I clear a stream? 
#card  #computer-science/programming-language/cpp
Call the method `clear()` from the stream. For example: `ss.clear()` 
^1687766725529

In C++, lets say I want to extract numbers from a string as I iterate across it and then transfer it to a variable count. How would I go about this using streams in C++? 
#card  #computer-science/programming-language/cpp
```cpp
#include <sstream>
#include <cctype>
std꞉꞉string uncompress(const std꞉꞉string& s) {
    std꞉꞉stringstream ss;
    std꞉꞉string result;
    for(auto it = s.begin(); it != s.end(); ++it) {
        if(std꞉꞉isdigit(*it)) {
            ss << *it;
        } else if(std꞉꞉isalpha(*it)) {
            int count = 0;
            ss >> count;
            result.append(count, *it); // append *it 'count' times to result
            ss.clear(); // clear the stringstream for next number
        }
    }
    return result;
}
```
^1687766725537

What is meant about C++ streams providing buffering? How is this different from `std꞉꞉strings`? 
#card  #computer-science/programming-language/cpp
- Buffers in C++ streams serve as an intermediary area where data can be stored temporarily while it's being transferred between two places in your program (such as between your program and the console, a file, or a string). The data you write to a stream might be stored in a buffer first, and then actually sent to its final destination when the buffer is flushed. Similarly, when reading data from a stream, the data might be read into a buffer first, and then your program reads from that buffer.
- Buffering provides several advantages:
	1. **Efficiency**: Reading or writing data one byte at a time can be slow, because each read or write operation might require a system call, which is expensive. By reading or writing larger chunks of data at a time, you can reduce the number of system calls and improve the performance of your program.
	2. **Flexibility**: Buffers allow for flexible ordering of I/O operations. For example, you can write data to a buffer in non-contiguous chunks, and it will be written out as one contiguous chunk when the buffer is flushed.
	3. **Smooth handling of data streams**: In real-time applications, buffers can store incoming data when it arrives faster than it can be processed, and release it when the program is ready.
- Strings, on the other hand, are just sequences of characters. They don't have built-in support for buffering because they don't involve transfer of data in the same way that I/O streams do. You can, however, create a buffer-like behavior with strings by concatenating many small strings into a larger one before doing a more expensive operation (like writing the string to a file), but this is a manual process and doesn't have the automatic flushing behavior of a real buffer.
- In the case of `std꞉꞉stringstream`, the stream internally uses a string as its buffer. This allows you to take advantage of the buffering behavior while working with strings.
^1687767007401

What was my second attempt for this problem? 
#card  #computer-science/programming-language/cpp
```cpp
#include <string>
#include <cctype>
// Time: O(n * m) n = # of groups, m = max length of group
// Space: O(n * m)
std꞉꞉string uncompress(std꞉꞉string s) {
    // todo
    const char* frontPtr = &s[0];
    const char* backPtr = &s[0];
    int dis {0};
    std꞉꞉string result = "";
    while(*frontPtr != '\0') {
        // if a char, sue to create the group to append to result
        if(isalpha(*frontPtr)) {
            // Get the group length
            dis = std꞉꞉stoi(std꞉꞉string(backPtr,frontPtr));
            while(dis != 0) {
                result.push_back(*frontPtr);
                dis--;
            }
            dis = 0;
            backPtr = frontPtr + 1;
        }
        frontPtr++;
    }
    return result;
}
void run() {
  // this function behaves as `main()` for the 'run' command
  // you may sandbox in this function, but should not remove it
}
```
^1687767210975

##### Attempt #3 (2023-26-06) ⏲️ 00:08:00

What did my third attempt for this problem look like? 
#card  #computer-science/programming-language/cpp
```cpp
#include <string>
#include <sstream>
#include <cctype>
std꞉꞉string uncompress(std꞉꞉string s) {
  // todo
  std꞉꞉string result;
  std꞉꞉stringstream ss;
  int groupLength {0};
  const char* it = &s[0];
  while(*it != '\0') {
    if(isalpha(*it)) {
      ss >> groupLength;
      result.append(groupLength, *it);
      ss.clear();
      groupLength = 0;
    }
    else {
      ss << *it;
    }
    it++;
  }
  return result;
}
void run() {
  // this function behaves as `main()` for the 'run' command
  // you may sandbox in this function, but should not remove it
}
```
^1687770561273

##### Attempt #4 (2023-22-07) ⏲️ 00:22:25

Is the valid C++ code?
```cpp
std::substr()
```
 
#card  #computer-science/programming-language/cpp
 No. The function `substr()` is a method of `std::string`.
^1690070505942

What is the easiest modern way in C++ to convert a `std::string` to an `int`? 
#card  #computer-science/programming-language/cpp
You can use the function `stoi()` from the standard library.
^1690070505950

How many parameters does `stdoi()` have? 
#card  #computer-science/programming-language/cpp
The function have three (1 being optional) parameters.
- First parameter is the string to convert
- Second parameter is an address of an integer to store the number of characters processed
- **Optional** The number base to use (Default is 10)
^1690070505958

What function should I use if I wish to convert a `char` to an `int`? 
#card  #computer-science/programming-language/cpp
Use the `atoi()` function.
^1690070505966

##### Attempt #5 (2023-31-07) ⏲️ 00:22:09

What is the difference between using `stoi` and just using `stringstream()`? 
#card  #computer-science/programming-language/cpp
- Both can get the same job done, `stringstream()` is only nicer when you just want to use a delimiter to fill in value to a container.
^1690838907864

What library is `stoi()` a part of? 
#card  #computer-science/programming-language/cpp
It is part of the `<cmath>` library.
^1690838907870

What is wrong with the following code?
```cpp
#include <string>
#include <algorithm>
#include <cctype>
#include <iostream>
using namespace std;
std::string uncompress(std::string s) {
    // todo
    std::string result = "";
    for(auto itF {s.begin()}; itF != s.end(); itF++) {
        auto itB = std::find_if_not(itF, s.end(), [](char ch){ return std::isdigit(ch); } );
        int repeatNum = std::stoi(std::string(itF,itB));
        while(repeatNum > 0) {
            result.push_back(*itB);
            repeatNum--;
        }
        itF = itB + 1;
    }
    return result;
}
```
#card  #computer-science/programming-language/cpp
- Incrementing `itF` *before* **again** incrementing it from the for–loop signature.
- When doing these LeetCode style assignments, but to use `while()`.
^1690838907875


#### Solution (Python)


#### Solution (JavaScript)


### 007. compress 💻

#### Solution (C++)

What is the **optimal** solution for this problem? 
#card  #computer-science/programming-language/cpp
- **Approach**:
	1. Simply set an front iterator (e.g., `itF` to the current string and and have another iterator set to find the first occurrence of an element in the input string that is not the previous element.
	2. Append to the result the distance is between `itF` and `itB` and the element at `itF`
	3. Set `itF` `itB`. 
	4. Repeat the general process again.
- **Asymptotic Complexity**:
	- 
^1690838907879

##### Attempt #1 (2023-22-01) ⏲️ 00:11:55

Is the following code valid?
```cpp
auto itSubEnd = std::find_if_not(it, s.end(), [](char ch) { return ch == *it; });
```
#card  #computer-science/programming-language/cpp
No, it is not. If you wish to use a value that was declared, outside the scope of the statement in your lambda function, you ***must specify it***.
```cpp
auto itSubEnd = std::find_if_not(it, s.end(), [it](char ch) { return ch == *it; });
```
^1690074384955

In modern C++, what is the modern way to convert an `int` to a string? 
#card  #computer-science/programming-language/cpp
Use the `std::string()` functions from the `<string>` library.
^1690074384964

How many parameters does `substr()` have? 
#card  #computer-science/programming-language/cpp
It has 2 parameters.
- **pos** - position of the first character to include
- **count** - length of substring
^1690074384972

In modern C++, how can you get a substring from a `std::string` when I wish to do so by using the two iterators which already point to positions in the string I wish to copy from? 
#card  #computer-science/programming-language/cpp
I can simply use the `std::string` constructor. For example….
```cpp
std::string s = "Hello, world!";
auto it1 = s.begin() + 7;
auto it2 = it1 + 5;
std::string subString(it1, it2);
std::cout << subString << std::endl; // Outputs "world"
```
^1690091210766


In the following code, is `subString` a **deep** or **shallow** copy? 
```cpp
std::string s = "Hello, world!";
auto it1 = s.begin() + 7;
auto it2 = it1 + 5;
std::string subString(it1, it2);
std::cout << subString << std::endl; // Outputs "world"
```
#card  #computer-science/programming-language/cpp
It is a **deep** copy. When using the `std::string` constructor, it creates a deep copy.
^1690091210773


##### Attempt #2 (2023-31-07) ⏲️ 00:27:27

Is the following valid syntax? 
`std::string result {""}`
^1691138538097
#card #computer-science/programming-language/cpp
Yes.
^1691138538102


Is the following code valid?
```cpp
result.push_back(static_cast<int>(std::distance(itF, itB)));
```
#card  #computer-science/programming-language/cpp
The code is using `push_back()` to push an `int` into a string of elements char. Should simply call `to_string` and use the `append()` function.
^1690838907895


#### Solution (Python)



#### Solution (JavaScript)



### 008. anagrams 💻

#### Solution (C++)

##### Attempt #1 (2023-22-07) ⏲️ 00:24:43

When an element, that does not previously exist in a `std::map` or `std::unordered_map` container, is inserted, what value does the expression return? 
#card  #computer-science/programming-language/cpp
```cpp
s1Map[ *(it1 + i) ] = s1Map[ *(it1 + i) ] + 1;
```
The expression, on the right side, `s1Map[ *(it1 + i) ]`, returns 0 if `*(it + i)` did not previously exist in the container.
^1690091210781

What library is `std::unordered_map` from? 
#card  #computer-science/programming-language/cpp
It is from the library `<unordered_map>`. 
^1690091210788

Is `std::ordered_map` from the library `<unordered_map>`? 
#card  #computer-science/programming-language/cpp
No, it is from the library `<unordered_map>`. 
^1690091210794


##### Attempt #2 (2023-31-07) ⏲️ 28:05:07

First and foremost, must anagrams have the same number of occurrences? 
#card  #computer-science/programming-language/cpp
Yes!!!
^1690838907900

What is the definition of an anagram? 
#card  #computer-science/programming-language/cpp
Containers that have the same elements and the same number of occurrences of those elements. 
^1690838907906

Is the following code valid? 
```cpp
map2[*it2] = map2[*it2]++;
```

#card  #computer-science/programming-language/cpp
Yes, but now how you intend it to be.  In the above case, you are essentially calling the post increment, so essentially you are just having `map2[*it2]` be incremented, but then having it be assigned to its previously self so it is essentially overwriting the increment. If you wisht to increment an element in a container, just do the following…
```cpp
map2[*it2]++;
```
^1690838907911

#### Solution (Python)

#### Solution (JavaScript)

### 009. most frequent char 💻

#### Solution (C++)

What is the most **optimal** solution? 
#card  #computer-science/programming-language/cpp
- **Approach**
	1. Build an `unordered_map` of all the elements and the number of occurrences there are in the input string.
	2. Iterate again over the current input string and, if the current element is greater than the current max number of occurences, set the element as the current max char.
	3. Return the current max char.
- **Asymptotic Complexity**:
	- Time: $\mathcal{O}(n)$
	- Space: $\mathcal{O}(n)$
^1690844033572

##### Attempt #1 ⏲️ 00:31:16

When building a `std::map` from the elements from a string, what is something I should I keep in mind? 
#card  #computer-science/programming-language/cpp
- Need to remember that iterating across the string to access key-values in the new built map still ends up with a time complexity being $\mathcal{O}(n)$.
^1690091210801

What should be default value for objects of type `char`? 
#card  #computer-science/programming-language/cpp
Should be set to the **null character** (i.e., `'\0'`). 
^1690091210808

What is the **null character** in C++? 
#card  #computer-science/programming-language/cpp
An artifact from C, the **null character** (i.e., `\0`) is used to mark the end of C-style strings.
^1690091210815

What is wrong with the following code?
```cpp
#include <string>
#include <utility>
#include <map>
#include <limits>
using namespace std;
char mostFrequentChar(std::string s) {
    // todo
    std::map<char,std::pair<int,int>> mapS; // 1st: numOccur 2nd: pos

    for(auto it = s.begin(); it != s.end(); it++) {
        if(mapS.find(*it) != mapS.end()) {
            mapS[*it] = make_pair(mapS[*it].first + 1, mapS[*it].second);
        }
        else {
            mapS[*it] =  make_pair(1, std::distance(s.begin(),it) );
        }
    }
    // Find now the max
    char maxChar = 'a';
    int currMax = -std::numeric_limits<int>::infinity();
    int currEarliestPos = std::numeric_limits<int>::max();
    for(auto it = s.begin(); it != s.end(); it++) {
        if(mapS[*it].first > currMax ) {
            maxChar = *it;
            currMax = mapS[*it].first;
            currEarliestPos = mapS[*it].second;
        }
        else if (mapS[*it].first == currMax && mapS[*it].second < currEarliestPos) {
            maxChar = *it;
            currMax = mapS[*it].first;
            currEarliestPos = mapS[*it].second;
        }
    }
    return maxChar;
}
void run() {
    // this function behaves as `main()` for the 'run' command
    // you may sandbox in this function, but should not remove it
}
```

#card  #computer-science/programming-language/cpp
- Nothing wrong with the code, however it is unnecessarily efficient. Remember that we are going to do another iteration across the string to determine which `char` is the earliest and has the maximum number of occurrences. As such, we only need to include in our `map` the number of occurrence, not also the position of the char. When we iterate again across the input string we can set the answer `char` to the current iterating element if it has a strictly larger number of occurrences than the current.
- P.S. Should use `unordered_map`
^1690844033579

What library is `std::pair` a part of? 
#card  #computer-science/programming-language/cpp
It is part of the `<utility>` library.
^1690844033586

What library is `std::tuple` a part of? 
#card  #computer-science/programming-language/cpp
It is part of the `<tuple>` library.
^1690844033593

How do you create a `std::pair` in C++? 
#card  #computer-science/programming-language/cpp
Follow the example below in calling the `std::make_pair()` function…
```cpp
#include <utility>
#include <iostream>
int main() {
    auto my_pair = std::make_pair(1, "hello");
    std::cout << my_pair.first << ' ' << my_pair.second << '\n';
    return 0;
}
```
^1690844033601

Is this valid code?
```cpp
std::map<char,std::pair<int,int>> mapS;
```

#card  #computer-science/programming-language/cpp
Yes, this is valid code. Specifically, the `std::pair` component.
^1690844033607

How do you create a `std::tuple` in C++? 
#card  #computer-science/programming-language/cpp
Follow the example below in calling the `std::make_tuple()` function…
```cpp
#include <tuple>
#include <iostream>
int main() {
    auto my_tuple = std::make_tuple(1, "hello", 3.14);
    std::cout << std::get<0>(my_tuple) << ' ' << std::get<1>(my_tuple) << ' ' << std::get<2>(my_tuple) << '\n';
    return 0;
}
```
^1690844033616

How do you access an element in a `std::pair`? 
#card  #computer-science/programming-language/cpp
Access the members `.first` and `.second` like so…
```cpp
#include <utility>
#include <iostream>
int main() {
    auto my_pair = std::make_pair(1, "hello");
    std::cout << my_pair.first << ' ' << my_pair.second << '\n';
    return 0;
}
```
^1690844033623

How do you access an element in a `std::tuple`? 
#card  #computer-science/programming-language/cpp
Use the `std::get<>()` function like so…
```cpp
#include <tuple>
#include <iostream>
int main() {
    auto my_tuple = std::make_tuple(1, "hello", 3.14);
    std::cout << std::get<0>(my_tuple) << ' ' << std::get<1>(my_tuple) << ' ' << std::get<2>(my_tuple) << '\n';
    return 0;
}
```
^1690844033630

#### Solution (Python)

#### Solution (JavaScript)

### 010. pair sum 💻

#### Solution (C++)

What is the **optimal** solution? 
#card  #computer-science/programming-language/cpp
- **Approach:**
	1. First iterate across the vector, and insert the elements into a map. 
		1. Check if the complement for the target is already found in the map, and if so, return the the current element position alongside the complement position which should be in the map already.
- **Asymptotic Analysis:**
	- Time: $\mathcal{O}(n)$
	- Space: $\mathcal{O}(n)$
^1690877619835

##### Attempt #1 ⏲️ 00:25:00

What is the return type of `std::distance()`? 
#card  #computer-science/programming-language/cpp
Should just be an `int`, but when using it in `std::array<int>{}`, need to `static_cast<int>()` the return type of `std::distance()`.
^1690091210824

Is the following snippet of code valid? 
```cpp
if(numMap.find(*it) != numMap.end()) {
	numMap[*it] = static_cast<int>( std::distance(numbers.begin(), it) );
}
```

#card  #computer-science/programming-language/cpp
- Yes, the following code snippet is valid, but *logically* wrong.
- If your **intention** is to insert `*it` if it is not currently in `numMap` then you want to change your condition in your `if` statement to…
```cpp
if(numMap.find(*it) == numMap.end) { // <- Means *it not found in numMap
// ...
}
```
^1690863832291

#### Solution (Python)

#### Solution (JavaScript)

### 011. pair product 💻

#### Solution (C++)

What is the **optimal solution** to this problem? 
#card  #computer-science/programming-language/cpp
- **Approach:**
	1. First iterate over each element of the input string, and if it does not exist, insert it and its position into our map.
		1. If the complement of the element does exist in the map (i.e., we already iterated pass it), return that position of that complement and the current position.
- **Time:**
	- Time: $\mathcal{O}(n)$
	- Space: $\mathcal{O}(n)$
^1690877619841

##### Attempt #1 (2023-22-07) ⏲️ 00:27:53

What is wrong with the following code?
```cpp
#include <array>
#include <vector>
#include <unordered_map>
// Iterate across, build map
// If target / numA = goal
std::array<int, 2> pairProduct(std::vector<int> numbers, int target) {
    // todo
    std::unordered_map<double, int> numsMap;
    for(auto it = numbers.begin(); it != numbers.end(); it++) {
        int itPos = static_cast<int>( std::distance(numbers.begin(), it) );
        numsMap[*it] = itPos;
    }
    for(auto it = numbers.begin(); it != numbers.end(); it++) {
        int itPos = static_cast<int>( std::distance(numbers.begin(), it) );
        if( numsMap.find(target/(*it)) != numsMap.end() ) {
            int numAPos = itPos;
            int numBPos = numsMap[target/(*it)];
            if (numAPos != numBPos) { // make sure not same index
                return std::array<int, 2> {numAPos, numBPos};
            }
        }
    }
    return std::array<int, 2>{0,0};
}
```
#card  #computer-science/programming-language/cpp
- The above code does not account for that, when finding the corresponding common divisor to another common divisor, we ***must*** account for float values.
- Must modify the code to be this… `numsMap.find( static_cast<double>(target) / (*it) )`
^1690091210832

##### Attempt #2 (2023-01-08) ⏲️ 00:08:00

Although not necessary for Structy’s variant of this problem, what **edge case** *must* I consider? 
#card  #computer-science/programming-language/cpp
Need to consider a case of the current element of the input string being 0, which in that case, before dividing, need to make sure I **don’t** divide by it and just continue/iterate to the next element of the container. 
^1690877619846

#### Solution (Python)

#### Solution (JavaScript)


### 012. check in 👨🏻‍🏫

#### Solution (C++)

#### Solution (Python)

#### Solution (JavaScript)


### 013. intersection 💻

#### Solution (C++)

What is the **optimal solution** to this problem? 
#card  #computer-science/programming-language/cpp
- **Approach:**
	1. First iterate over each element of the input string, and if it does not exist, insert it and its position into our map.
		1. If the complement of the element does exist in the map (i.e., we already iterated pass it), return that position of that complement and the current position.
- **Time:**
	- Time: $\mathcal{O}(n)$
	- Space: $\mathcal{O}(n)$
^1690877619841


##### Attempt #1 (2023-01-08) ⏲️ 00:46:00 

Is the following code valid? 
 ```cpp
#include <vector>  
#include <unordered_map>  
using namespace std;  
// Gonna have to iterate across each    
// T: O(n)  
/// S: O(n)  
std::vector<int> intersection(std::vector<int> a, std::vector<int> b) {  
    // todo  
    unordered_map<int,int> interMap;  
    vector<int> ans;  
    for(auto it = a.begin(); it != a.end(); it++) {  
        if(interMap.find(*it) == interMap.end()) {  
            interMap[*it] = 1;  
        }  
    }    
    for(auto it = b.begin(); it != b.end(); it++) {  
        if(interMap.find(*it) == interMap.end()) {  
            interMap[*it] = 1;  
        }  
        if(interMap.find(*it) != interMap.end()) {  
            ans.push_back( *it );  
        }  
    }  
    return ans;  
}  
void run() {  
    // this function behaves as `main()` for the 'run' command  
    // you may sandbox in this function, but should not remove it
}
```
#card  #computer-science/programming-language/cpp
While the above code is valid, the logic is incorrect. When doing the iteration of b, the logic inserts the current element into our map if it is not already there. 
- Should remove that part and then the code should work.
- This has the issue of now *also* inserting all elements of b into our `ans` vector.
^1690877619850

What is the time complexity of calling `sort()`? 
#card  #computer-science/programming-language/cpp
Time complexity: $\mathcal{O}(n \log n)$
^1690877619855

Is `sort()` a method of a container or is it a generic function? 
#card  #computer-science/programming-language/cpp
It is a generic function.
^1690877619860

How many parameters does `std()` sort have? 
#card  #computer-science/programming-language/cpp
Two required, one optional
1. Starting pos
2. Ending pos
3. *Optional* Comparator (e.g., `std::greater<int>`)
^1690877631533

How would you sort a `vector<int>` called (`ans`) from least to greatest? 
#card  #computer-science/programming-language/cpp
```cpp
std::sort(ans.begin(), ans.end(), std::less<int>);
```
…or…
```cpp
std::sort(ans.begin(), ans.end());
```
^1690877780782

How would you sort a `vector<int>` called (`ans`) from greatest to least? 
#card  #computer-science/programming-language/cpp
```cpp
std::sort(ans.begin(), ans.end(), std::greater<int>);
```
^1690878529302

#### Solution (Python)


#### Solution (JavaScript)

### 014. five sort 💻

#### Solution (C++)

What is the optimal solution to this problem? 
#card  #computer-science/programming-language/cpp
- **Approach**: Just use the `partition?()` function from the algorithm library.
- **Time Complexity:**
	- Time: $\mathcal{O}(n)$
	- Space: $\mathcal{O}(1)$
^1690880891630

##### Attempt #1 (2023-01-08) ⏲️ 00:05:45

Does `sort()` have the capability to sort all elements of a certain type to the end or beginning of a container? 
#card  #computer-science/programming-language/cpp
No, it does not. For the objective, one should use the `partition()` function. 
^1690880013708

What function should one use if they wish to sort all elements of a certain type to the end or beginning of a container? 
#card  #computer-science/programming-language/cpp
Use the `partition()` function. 
^1690880013717

How many arguments does `partition()` have? 
#card  #computer-science/programming-language/cpp
It has three arguments…
	1. A `ForwardIterator` for the starting position of the iteration
	2. A `ForwardIterator` for the ending position of the iteration
	3. A predicate.       
An example of a predicate…
```cpp
[](int i){ return i != 5}
``` 
 *Essentially all values that values that return true will **precede** all values that return false.* 
^1690880688295


What predicate should I make if I want to move all elements that are 5 to the end of a vector? 
#card  #computer-science/programming-language/cpp
```cpp
[](int i){ return i != 5}
```
Notice the change not equal sign.
^1690880762626


What predicate should I make if I want to move all elements that are 5 to the front of a vector? 
#card  #computer-science/programming-language/cpp
```cpp
[](int i){ return i == 5}
```
Notice the equal sign.
^1690880688300


What is the difference between `stable_partition()` and `partition()`? 
#card  #computer-science/programming-language/cpp
`stable_partition` preserves the order of elements.
^1690880013747

What is the time complexity of `partition()`? 
#card  #computer-science/programming-language/cpp
Time complexity: $\mathcal{O}(n)$
^1690880013752

Is the generic function `partition(n)` in-place? 
#card  #computer-science/programming-language/cpp
Yes.
^1690880013756

What is the time complexity of `stable_partition()`? 
#card  #computer-science/programming-language/cpp
`std::space_partition()` is an adaptive algorithm, which means the time complexity depends on the amount of memory available.
- If enough memory available, the function can use a buffer to achieve a time complexity of $\mathcal{O}(n)$.
	- Space complexity in this case is $\mathcal{O}(n)$
- If there is not enough memory available, the function uses an in-place approach with a time complexity of $\mathcal{O}(n \log n)$
	- Space complexity in this case is $\mathcal{O}(1)$ 
^1690880013761

What is the space complexity of `stable_partition()`? 
#card  #computer-science/programming-language/cpp
- Depends on the amount of memory.
	- If there is enough available, the function can use a buffer to achieve $\mathcal{O}(n)$.
	- If there is not enough memory, the function uses an in-place with a space complexity of $\mathcal{O}(1)$ .
^1690880013765


What is the space complexity of `partiton()` 
#card  #computer-science/programming-language/cpp
Space complexity… $\mathcal{O}(1)$
^1690880013769

#### Solution (Python)

#### Solution (JavaScript)

### 015. array and string quiz 📝

What is the Big-O time complexity of searching for a key in an `std::unordered_map`? 
#card  #computer-science/programming-language/cpp
$\mathcal{O}(1)$, Constant time
^1691138349598

Given an array of n elements, how many different triplets of elements can be formed? 
#card  #computer-science/programming-language/cpp
There are $n^3$ possible triplets.
^1691138349603

According to Alvin’s advice, should you avoid watching the approach and walkthrough videos when you are struggling with a problem? 
#card  #computer-science/programming-language/cpp
Nope! Alvin encourages you to use the videos when you are stuck. For any given concept, there will be more practice available in the future - so the fun isn't spoiled.
^1691138349608

What is the Big-O time complexity of searching for an element in a `std::vector`? 
#card  #computer-science/programming-language/cpp
$\mathcal{O}(n)$, Linear
^1691138349614

What is the Big-O time complexity of searching for an item in a `std::unordered_set`? 
#card  #computer-science/programming-language/cpp
$\mathcal{O}(1)$, Constant time
^1691138349619

Given an array of n elements, how many different pairs of elements can be formed? 
#card  #computer-science/programming-language/cpp
There are $n^2$ possible pairs.
^1691138349625

### 016. array and string wrap up 👨🏻‍🏫

#### Solution (C++)

#### Solution (Python)

#### Solution (JavaScript)







