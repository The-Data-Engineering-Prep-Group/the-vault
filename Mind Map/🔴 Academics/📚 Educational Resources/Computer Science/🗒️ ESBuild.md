
---
author: 
publisher: 
published: 
tags: [computer-science/technology/esbuild, educational-resource/esbuild, study-note] 
cards-deck: Default::Computer Science
---

# ESBuild

Are web bundlers classified as frameworks or libraries? #card 
Neither, they classified as tools or technologies.

In essence, what does  a web bundler do? #card 
Used to bundle multiple JavaScript files and other assets (e.g., CSS files, images, etc.) reducing the number of network requests and improving performance.

What are are some popular web bundlers? #card 
- Vite
- Webpack
- Parcel
- ESBuild
- SWC
- Rollup

```js
// esbuild.config.mjs

import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import { execSync } from "child_process"

const banner =
	`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const buildType = process.env.npm_config_buildType || 'debug';
const outputDir = buildType === 'release' ? 'build/release' : 'build/debug';

// Check to see if buildType is release, so we know that prod "True" (i.e., no need for "watching" the project)
const prod = (buildType === "release");

// Run the PowerShell script here
try {
	// execSync('sudo pwsh ./scripts/install-plugin.ps1', { stdio: 'inherit' });
} catch (err) {
	console.error('Failed to run PowerShell script:', err);
	process.exit(1);
}

const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ["./src/main.ts"],
	bundle: true,
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab",
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
		...builtins],
	format: "cjs",
	target: "es2018",
	logLevel: "info",
	sourcemap: prod ? false : "inline",
	treeShaking: true,
	outdir: "build",
});

if (prod) {
	await context.rebuild();
	process.exit(0);
} else {
	await context.watch();
}

// TODO 1: Find a way to make the clean argument system agnostic
// TODO 2: ...
```
In the code above, when does the PowerShell script execute? #card 
The PowerShell executes *before* the `context.rebuild()` or `context.watch()` is called.

Explain what the following line does…
```js
const buildType = process.env.npm_config_buildType || buildTypeDebug 
```
#card 

Focusing on the right-side of the statement…
- `process.env` is an object in Node.js that contains all environment variables.
- `npm_config_buildType` is an environment variable set at runtime.
	- For example, if you run the script using the command `npm run my-script --buildType=release`, npm automatically adds that to the `process.env` with the prefix `npm_config_`, hence `process.env.npm_config_buildType` will equal `release`.
- The `||` symbol means “logical OR.” In this case, it is used to provide a default value (‘`debug`’) if `process.env.npm_config_buildType` is not set.

What is an object in Node.js that contains all environment variables? #card-reverse 
`process.env`

What prefix does npm automatically add to all user environment variables? #card 
- `npm_config_`
- For example,  if you run the script using the command `npm run my-script --buildType=release`, npm automatically adds that to the `process.env` with the prefix `npm_config_`, hence `process.env.npm_config_buildType` will equal `release`.

What does `stdio` mean in the context of the following statement?
```js
execSync('sudo pwsh ./scripts/install-plugin.ps1', { stdio: 'inherit' });
```
#card 
- The `stdio` option, when used with `execSync`, is for controlling the I/O streams of child processes. `stdio` can be used to specify what should be done with `stdin`, `stdout`, and `stderr` of the child processes.
	- `stdio: pipe` Pipes the child process’s `stdin`, `stdout`, and `stderr` to the parent.
	- `stdio: ignore` No stream will be piped/ignored for all child processes.
	- `stdio: inherit` Child and parent process will share `stdin`, `stdout`, and `stderr`.

In the context of `execSync`, specifically the `{stdio: '???' }` option, the {inherit} option can be useful when you want the child process to interact with the same console/terminal as the parent process, such as reading input from the user or logging directly to the console.

In the context of `execSync`, specifically the `{stdio: '???' }` option, what value should I use so that the the `stderr` and `stdout` form the child process are returned to the parent?
#card 
`pipe`

In the context of `execSync`, specifically the `{stdio: '???'}` option, when the value is `pipe` can the child process directly read the parent’s stdin? #card 
No.

In the context of `execSync`, specifically the `{stdio: '???'}` option, when the value is `inherit` can the child you write something to `stdin` in the parent process and the child process will be able to read it? #card 
Yes.

Does the `watch` method in ESBuild provide direct functionality to run arbitrary commands or scripts upon file changes? #card 
- No, it does it now. If you wish to do so, you must script it yourself or use an outdated library (i.e. [**chokidar**](https://github.com/paulmillr/chokidar]) ).
	- If you desire to script the file watch yourself, you would need to use Node’s built-in filesystem module - **fs**
	- Note though that `fs.watch` can be tricky to get working across different OSes, because the underlying system events it hooks into can behave differently.

What is the downside of trying to implement your own script so you can provide directly functionality to run arbitrarily commands of scripts upon file changes? #card 
- You would need to use  use Node’s built-in filesystem module - **fs**
	- Note though that `fs.watch` can be tricky to get working across different OSes, because the underlying system events it hooks into can behave differently.

What is one significant downside of ESBuild compared to other bundlers? #card 
- As of July 2023, ESBuild does *not* provide direct functionality to run arbitrary commands or scripts upon file changes
- In contrast, both **Rollup** and **Vue** have plugin systems that allow you to run arbitrary code as part of their lifecycle, including after a rebuild in watch mode.
	- **Rollup** Gives you the ability to hook into its build lifecycle with plugins.
	  ```js
	  import rollup from 'rollup'
	  import { execSync } from 'child_process'
	  
	  rollup.rollup({
	      input: './src/main.ts'
	      plugins: [{
	          writeBundle() {
	              execSync("pwsh ./scripts/install-plugin.ps1", {stdio: "inherit"})
	          }
	      }]
	  }).then(bundle => bundle.watch());
	  ```
		- The `writeBundle` hook executes after Rollup has written to the disk, which allows you to run commands after each rebuild in watch mode.
	- **Vite** has a similar feature with plugins
	  ```js
	  import { createServer } from 'vite'
	  import { execSync } from 'child_process'
	  
	  createServer({
	      plugins: [{
	          name: "run-script-after-build",
	          handleHotUpdate() {
	             execSync("pwsh ./scritps/install-plugin.ps1", {stdio: "inherit"});
	          },
	      }],
	  }).then(server => server.listen())
	  ```
		- The `handleHotUpdate` hook in Vite is executed after a module is hot updated. You can use this hook to run your PowerShell script after each rebuild in development mode.