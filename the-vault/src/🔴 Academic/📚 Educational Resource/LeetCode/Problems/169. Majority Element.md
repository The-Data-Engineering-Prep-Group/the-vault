---
title: 169. Majority Element
authors:
  - Edmund Leibert III
created: 2023-12-07T14:22
updated: 2023-12-07T23:10
tags:
  - üî¥-academic/üìö-educational-resource/name/leetcode/üîñ/problems/169-majority-element
  - üî¥-academic/üìö-educational-resource/format/website
  - üî¥-academic/üìö-educational-resource/discipline/computer-science/
  - üî¥-academic/üìö-educational-resource/name/leetcode/üè∑Ô∏è/problems/premium/no
  - üî¥-academic/üìö-educational-resource/name/leetcode/üè∑Ô∏è/problems/difficulty/easy
  - üî¥-academic/üìö-educational-resource/name/leetcode/üè∑Ô∏è/problems/tag/topic/array
  - üî¥-academic/üìö-educational-resource/name/leetcode/üè∑Ô∏è/problems/tag/topic/hash-table
  - üî¥-academic/üìö-educational-resource/name/leetcode/üè∑Ô∏è/problems/tag/topic/divide-and-conquer
  - üî¥-academic/üìö-educational-resource/name/leetcode/üè∑Ô∏è/problems/tag/topic/sorting
  - üî¥-academic/üìö-educational-resource/name/leetcode/üè∑Ô∏è/problems/tag/topic/counting
  - study-note
cards-deck: üî¥ Academic::üìö Educational Resource::LeetCode::Problems::169. Majority Element
---

# 169. Majority Element

---

> [!ABSTRACT]+
> Notes pertaining to [169. Majority Element - LeetCode](https://leetcode.com/problems/majority-element/description/).

---

> [!INFO]+
> **Previous Notes**:
> 

---

## :TiNotes: Description

The {1:_majority element_} is the element that {2:appears more than¬†`‚åän / 2‚åã`¬†times}.
^1701995473068

## :BoBxBookOpen: Editorial

### **Solution**

#### **Approach 1: Brute Force**

##### **Intuition**

##### **Algorithm**

##### **Implementation**

##### **Complexity Analysis**

#### **Approach 2: HashMap**

##### **Intuition**

##### **Algorithm**

##### **Implementation**

##### **Complexity Analysis**

#### **Approach 3: Sorting**

##### **Intuition**

##### **Algorithm**

##### **Implementation**

##### **Complexity Analysis**

#### **Approach 4: Bit Manipulation**

##### **Intuition**

##### **Algorithm**

##### **Implementation**

##### **Complexity Analysis**

#### **Approach 5: Randomization**

##### **Intuition**

##### **Algorithm**

##### **Implementation**

##### **Complexity Analysis**

#### **Approach 6: Divide and Conquer**

##### **Intuition**

##### **Algorithm**

##### **Implementation**

##### **Complexity Analysis**

#### **Approach 7: Boyer-Moore Voting Algorithm**

##### **Intuition**

##### **Algorithm**

##### **Implementation**

##### **Complexity Analysis**

## :RiFlaskLine: Solutions

## :RiHistoryLine: Submissions

### :SiJavascript: JavaScript

### :SiTypescript: TypeScript

### :SiGo: Go

### :SiRust: Rust

### :SiPython: Python

### :SiCsharp: C\#

### :SiCplusplus: C++

#### **Attempt #1** ‚Ä¢ üìÜ 2023-12-07 14:49 -08:00 ‚Ä¢ ‚ùå Failed ‚Ä¢ ‚è±Ô∏è 0:07:41 ‚Ä¢ \[Author(s): Edmund Leibert III\]

Ôπá<br>
Is the following code a valid solution to this problem?

```cpp
// Need to to do one pass and use a map

#include <cmath>
#include <unordered_map>

using namespace std;

class Solution {
public:
	int majorityElement(vector<int>& nums) {

	unordered_map<int,int> num_map;
	
	for(const auto& num : nums) {
		if(num_map.find(num) == num_map.end()) {
			num_map[num] = 1;
		}
		else {
			num_map[num] = num_map[num] + 1;
		}
	}
	
	// Second pass
	for(const auto& num : nums) {
		if(num_map[num] > floor(nums.size()/2) ) {
			return num;
		}
	}
	
	return -1;
	}
};
```

#card #üî¥-academic/üìö-educational-resource/discipline/computer-science/programming-language/cpp 

While the above code is _correct_, it is **not** _efficient_.

The above approach uses a `std::unordered_map`. In consequence, although the above algorithm has a worst-case time complexity of $\mathcal{O}(n)$, the worst-case space complexity is $\mathcal{O}(n)$.

‚åÇ
<br>Ôπà<br>^1701995473115

---

## :EiZoteroItem: Bibliography

---

> [!INFO]+ 
> **Next Note(s)**:
> 

---
